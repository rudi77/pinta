
// Relative Path: src\core\database.py
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import DeclarativeBase
import os
from typing import AsyncGenerator

# Database URL
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite+aiosqlite:///./maler_kostenvoranschlag.db")

# Create async engine
engine = create_async_engine(
    DATABASE_URL,
    echo=True,  # Set to False in production
    future=True
)

# Create async session factory
AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False
)

class Base(DeclarativeBase):
    pass

async def init_db():
    """Initialize database tables"""
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """Dependency to get database session"""
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()





// Relative Path: src\core\security.py
from passlib.context import CryptContext
from jose import JWTError, jwt
from datetime import datetime, timedelta, timezone
from typing import Optional
import os

# Security configuration
SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key-change-in-production")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# Password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against its hash"""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Hash a password"""
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Create a JWT access token"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_token(token: str) -> Optional[dict]:
    """Verify and decode a JWT token"""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None


# FastAPI dependencies
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from src.core.database import get_db
from src.models.models import User

security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: AsyncSession = Depends(get_db)
) -> User:
    """Get current authenticated user"""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        payload = verify_token(credentials.credentials)
        if payload is None:
            raise credentials_exception
            
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
            
    except JWTError:
        raise credentials_exception
    
    # Get user from database
    result = await db.execute(select(User).where(User.email == email))
    user = result.scalar_one_or_none()
    
    if user is None:
        raise credentials_exception
        
    return user

async def get_current_active_user(current_user: User = Depends(get_current_user)) -> User:
    """Get current active user"""
    if not current_user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user





// Relative Path: src\core\__init__.py
# Core package





// Relative Path: src\models\models.py
from sqlalchemy import Column, Integer, String, Float, Text, DateTime, Boolean, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from src.core.database import Base

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(50), unique=True, index=True, nullable=False)
    email = Column(String(100), unique=True, index=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    
    # Profile information
    company_name = Column(String(100))
    phone = Column(String(20))
    address = Column(Text)
    
    # Subscription and quota
    is_premium = Column(Boolean, default=False)
    premium_until = Column(DateTime)
    quotes_this_month = Column(Integer, default=0)
    additional_quotes = Column(Integer, default=0)
    
    # Timestamps
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    # Relationships
    quotes = relationship("Quote", back_populates="user", cascade="all, delete-orphan")
    documents = relationship("Document", back_populates="user", cascade="all, delete-orphan")
    payments = relationship("Payment", back_populates="user", cascade="all, delete-orphan")

class Quote(Base):
    __tablename__ = "quotes"
    
    id = Column(Integer, primary_key=True, index=True)
    quote_number = Column(String(50), unique=True, index=True, nullable=False)
    
    # User reference
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    
    # Customer information
    customer_name = Column(String(100), nullable=False)
    customer_email = Column(String(100))
    customer_phone = Column(String(20))
    customer_address = Column(Text)
    
    # Project information
    project_title = Column(String(200), nullable=False)
    project_description = Column(Text)
    
    # Pricing
    total_amount = Column(Float)
    labor_hours = Column(Float)
    hourly_rate = Column(Float)
    material_cost = Column(Float)
    additional_costs = Column(Float)
    
    # Status and processing
    status = Column(String(20), default="draft")  # draft, completed, sent, accepted, rejected
    ai_processing_status = Column(String(20), default="pending")  # pending, processing, completed, failed
    
    # Timestamps
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    # Relationships
    user = relationship("User", back_populates="quotes")
    quote_items = relationship("QuoteItem", back_populates="quote", cascade="all, delete-orphan")

class QuoteItem(Base):
    __tablename__ = "quote_items"
    
    id = Column(Integer, primary_key=True, index=True)
    quote_id = Column(Integer, ForeignKey("quotes.id"), nullable=False)
    
    position = Column(Integer, nullable=False)
    description = Column(Text, nullable=False)
    quantity = Column(Float, nullable=False)
    unit = Column(String(20), nullable=False)
    unit_price = Column(Float, nullable=False)
    total_price = Column(Float, nullable=False)
    
    # Additional information
    room_name = Column(String(100))
    area_sqm = Column(Float)
    work_type = Column(String(50))  # painting, priming, etc.
    
    # Timestamps
    created_at = Column(DateTime, server_default=func.now())
    
    # Relationships
    quote = relationship("Quote", back_populates="quote_items")

class Document(Base):
    __tablename__ = "documents"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    quote_id = Column(Integer, ForeignKey("quotes.id"))
    
    filename = Column(String(255), nullable=False)
    original_filename = Column(String(255), nullable=False)
    file_path = Column(String(500), nullable=False)
    file_size = Column(Integer)
    mime_type = Column(String(100))
    
    # OCR and analysis results
    extracted_text = Column(Text)
    analysis_result = Column(Text)  # JSON string
    processing_status = Column(String(20), default="pending")  # pending, processing, completed, failed
    
    # Timestamps
    created_at = Column(DateTime, server_default=func.now())
    
    # Relationships
    user = relationship("User", back_populates="documents")

class Payment(Base):
    __tablename__ = "payments"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    
    # Stripe information
    stripe_payment_intent_id = Column(String(200), unique=True)
    stripe_session_id = Column(String(200), unique=True)
    
    amount = Column(Float, nullable=False)
    currency = Column(String(3), default="EUR")
    status = Column(String(50), nullable=False)  # pending, completed, failed, refunded
    
    payment_type = Column(String(50), nullable=False)  # premium_upgrade, additional_quotes
    description = Column(String(200))
    
    # Timestamps
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    # Relationships
    user = relationship("User", back_populates="payments")





// Relative Path: src\models\user.py
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)

    def __repr__(self):
        return f'<User {self.username}>'

    def to_dict(self):
        return {
            'id': self.id,
            'username': self.username,
            'email': self.email
        }




// Relative Path: src\models\__init__.py
# Models package





// Relative Path: src\routes\ai.py
from fastapi import APIRouter, HTTPException, Depends, UploadFile, File
from typing import List, Dict, Any, Optional
import json
import logging
from datetime import datetime

from src.services.ai_service import AIService
from src.core.security import get_current_user
from src.models.models import User
from src.schemas.schemas import (
    AIAnalysisRequest, 
    AIAnalysisResponse,
    AIQuestionResponse,
    AIFollowUpRequest,
    AIQuoteGenerationRequest,
    AIQuoteGenerationResponse
)

router = APIRouter(tags=["AI"])
logger = logging.getLogger(__name__)

# Initialize AI service
ai_service = AIService()

@router.post("/analyze-input", response_model=AIAnalysisResponse)
async def analyze_project_input(
    request: AIAnalysisRequest,
    current_user: User = Depends(get_current_user)
):
    """Analyze project description and generate intelligent follow-up questions"""
    try:
        logger.info(f"Analyzing project input for user {current_user.id}")
        
        result = await ai_service.analyze_project_description(
            description=request.description,
            context=request.context or "initial_input"
        )
        
        return AIAnalysisResponse(
            analysis=result.get("analysis", {}),
            questions=result.get("questions", []),
            suggestions=result.get("suggestions", []),
            success=True
        )
        
    except Exception as e:
        logger.error(f"Error analyzing project input: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to analyze project input")

@router.post("/ask-question", response_model=AIQuestionResponse)
async def ask_follow_up_question(
    request: AIFollowUpRequest,
    current_user: User = Depends(get_current_user)
):
    """Handle follow-up questions in the AI conversation"""
    try:
        logger.info(f"Processing follow-up question for user {current_user.id}")
        
        result = await ai_service.ask_follow_up_question(
            conversation_history=request.conversation_history,
            user_message=request.message
        )
        
        return AIQuestionResponse(
            response=result.get("response", ""),
            needs_more_info=result.get("needs_more_info", False),
            suggested_questions=result.get("suggested_questions", []),
            success=True
        )
        
    except Exception as e:
        logger.error(f"Error processing follow-up question: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to process question")

@router.post("/generate-quote", response_model=AIQuoteGenerationResponse)
async def generate_quote_with_ai(
    request: AIQuoteGenerationRequest,
    current_user: User = Depends(get_current_user)
):
    """Generate a detailed quote based on project data and user answers"""
    try:
        logger.info(f"Generating AI quote for user {current_user.id}")
        
        result = await ai_service.process_answers_and_generate_quote(
            project_data=request.project_data,
            answers=request.answers
        )
        
        return AIQuoteGenerationResponse(
            quote=result.get("quote", {}),
            items=result.get("items", []),
            notes=result.get("notes", ""),
            recommendations=result.get("recommendations", []),
            success=True
        )
        
    except Exception as e:
        logger.error(f"Error generating AI quote: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to generate quote")

@router.post("/upload-document")
async def upload_document_for_analysis(
    file: UploadFile = File(...),
    current_user: User = Depends(get_current_user)
):
    """Upload and analyze documents (PDFs, images) for project information"""
    try:
        logger.info(f"Processing document upload for user {current_user.id}")
        
        # Validate file type
        allowed_types = ['application/pdf', 'image/jpeg', 'image/png', 'image/webp']
        if file.content_type not in allowed_types:
            raise HTTPException(
                status_code=400, 
                detail="Unsupported file type. Please upload PDF, JPEG, PNG, or WebP files."
            )
        
        # Read file content
        content = await file.read()
        
        # For now, return a mock response
        # In production, you would implement OCR and document analysis
        return {
            "success": True,
            "filename": file.filename,
            "size": len(content),
            "analysis": {
                "extracted_text": "Mock extracted text from document",
                "detected_rooms": ["Wohnzimmer", "Küche"],
                "estimated_area": 45,
                "notes": "Document analysis is currently in development"
            },
            "message": "Document uploaded successfully. Analysis feature coming soon."
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error processing document upload: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to process document")

@router.get("/conversation-history/{quote_id}")
async def get_conversation_history(
    quote_id: int,
    current_user: User = Depends(get_current_user)
):
    """Get conversation history for a specific quote"""
    try:
        # For now, return mock conversation history
        # In production, you would fetch from database
        return {
            "quote_id": quote_id,
            "conversation": [
                {
                    "role": "assistant",
                    "content": "Hallo! Ich helfe Ihnen bei der Erstellung Ihres Kostenvoranschlags. Können Sie mir mehr über Ihr Projekt erzählen?",
                    "timestamp": datetime.now().isoformat()
                },
                {
                    "role": "user", 
                    "content": "Ich möchte mein Wohnzimmer streichen lassen.",
                    "timestamp": datetime.now().isoformat()
                }
            ],
            "success": True
        }
        
    except Exception as e:
        logger.error(f"Error fetching conversation history: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to fetch conversation history")

@router.get("/ai-status")
async def get_ai_status():
    """Get current AI service status and capabilities"""
    return {
        "ai_enabled": ai_service.enabled,
        "model": ai_service.model if ai_service.enabled else None,
        "capabilities": {
            "project_analysis": True,
            "question_generation": True,
            "quote_generation": True,
            "document_analysis": False,  # Coming soon
            "conversation_memory": True
        },
        "status": "operational" if ai_service.enabled else "mock_mode"
    }





// Relative Path: src\routes\auth.py
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from typing import Optional

from src.core.database import get_db
from src.core.security import verify_password, get_password_hash, create_access_token, verify_token
from src.models.models import User
from src.schemas.schemas import UserCreate, UserResponse, LoginRequest, Token, SuccessResponse

router = APIRouter()
security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: AsyncSession = Depends(get_db)
) -> User:
    """Get current authenticated user"""
    token = credentials.credentials
    payload = verify_token(token)
    
    if payload is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    username: str = payload.get("sub")
    if username is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Get user from database
    result = await db.execute(select(User).where(User.username == username))
    user = result.scalar_one_or_none()
    
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    return user

@router.post("/register", response_model=SuccessResponse)
async def register(user_data: UserCreate, db: AsyncSession = Depends(get_db)):
    """Register a new user"""
    
    # Check if user already exists
    result = await db.execute(
        select(User).where(
            (User.email == user_data.email) | (User.username == user_data.username)
        )
    )
    existing_user = result.scalar_one_or_none()
    
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="User with this email or username already exists"
        )
    
    # Create new user
    hashed_password = get_password_hash(user_data.password)
    db_user = User(
        username=user_data.username,
        email=user_data.email,
        hashed_password=hashed_password,
        company_name=user_data.company_name,
        phone=user_data.phone,
        address=user_data.address
    )
    
    db.add(db_user)
    await db.commit()
    await db.refresh(db_user)
    
    return SuccessResponse(message="User registered successfully")

@router.post("/login", response_model=Token)
async def login(login_data: LoginRequest, db: AsyncSession = Depends(get_db)):
    """Authenticate user and return access token"""
    
    # Get user by email
    result = await db.execute(select(User).where(User.email == login_data.email))
    user = result.scalar_one_or_none()
    
    if not user or not verify_password(login_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Create access token
    access_token = create_access_token(data={"sub": user.username})
    
    return Token(access_token=access_token, token_type="bearer")

@router.get("/me", response_model=UserResponse)
async def get_current_user_info(current_user: User = Depends(get_current_user)):
    """Get current user information"""
    return current_user

@router.post("/logout", response_model=SuccessResponse)
async def logout():
    """Logout user (client should discard token)"""
    return SuccessResponse(message="Logged out successfully")





// Relative Path: src\routes\payments.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update
from typing import Dict
import stripe
import os

from src.core.database import get_db
from src.routes.auth import get_current_user
from src.models.models import User, Payment
from src.schemas.schemas import PaymentCreate, PaymentResponse, SuccessResponse

router = APIRouter()

# Stripe configuration
stripe.api_key = os.getenv("STRIPE_SECRET_KEY")
STRIPE_PRICE_ID = os.getenv("STRIPE_PRICE_ID", "price_premium_monthly")

@router.post("/create-checkout-session")
async def create_checkout_session(
    success_url: str,
    cancel_url: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Create Stripe checkout session for premium upgrade"""
    
    try:
        checkout_session = stripe.checkout.Session.create(
            payment_method_types=['card'],
            line_items=[{
                'price': STRIPE_PRICE_ID,
                'quantity': 1,
            }],
            mode='subscription',
            success_url=success_url,
            cancel_url=cancel_url,
            customer_email=current_user.email,
            metadata={
                'user_id': current_user.id,
                'payment_type': 'premium_upgrade'
            }
        )
        
        # Create payment record
        payment = Payment(
            user_id=current_user.id,
            stripe_session_id=checkout_session.id,
            amount=29.99,  # Premium price
            currency="EUR",
            status="pending",
            payment_type="premium_upgrade",
            description="Premium Subscription"
        )
        
        db.add(payment)
        await db.commit()
        
        return {
            "success": True,
            "checkout_url": checkout_session.url,
            "session_id": checkout_session.id
        }
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to create checkout session: {str(e)}"
        )

@router.post("/create-additional-quotes-session")
async def create_additional_quotes_session(
    amount: float,
    description: str,
    success_url: str,
    cancel_url: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Create checkout session for additional quotes"""
    
    try:
        checkout_session = stripe.checkout.Session.create(
            payment_method_types=['card'],
            line_items=[{
                'price_data': {
                    'currency': 'eur',
                    'product_data': {
                        'name': description,
                    },
                    'unit_amount': int(amount * 100),  # Convert to cents
                },
                'quantity': 1,
            }],
            mode='payment',
            success_url=success_url,
            cancel_url=cancel_url,
            customer_email=current_user.email,
            metadata={
                'user_id': current_user.id,
                'payment_type': 'additional_quotes',
                'amount': amount
            }
        )
        
        # Create payment record
        payment = Payment(
            user_id=current_user.id,
            stripe_session_id=checkout_session.id,
            amount=amount,
            currency="EUR",
            status="pending",
            payment_type="additional_quotes",
            description=description
        )
        
        db.add(payment)
        await db.commit()
        
        return {
            "success": True,
            "checkout_url": checkout_session.url,
            "session_id": checkout_session.id
        }
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to create checkout session: {str(e)}"
        )

@router.get("/quota-info")
async def get_quota_info(current_user: User = Depends(get_current_user)):
    """Get current user quota information"""
    
    total_available = 3  # Free tier
    if current_user.is_premium:
        total_available = -1  # Unlimited
    
    quotes_remaining = max(0, total_available - current_user.quotes_this_month) if total_available > 0 else -1
    
    return {
        "success": True,
        "quota": {
            "is_premium": current_user.is_premium,
            "unlimited": current_user.is_premium,
            "total_available": total_available,
            "quotes_used": current_user.quotes_this_month,
            "quotes_remaining": quotes_remaining,
            "additional_quotes": current_user.additional_quotes
        }
    }

@router.post("/webhook")
async def stripe_webhook(
    request: Dict,
    db: AsyncSession = Depends(get_db)
):
    """Handle Stripe webhook events"""
    
    # In a real implementation, you would verify the webhook signature
    # For now, we'll process the event directly
    
    event_type = request.get('type')
    data = request.get('data', {}).get('object', {})
    
    if event_type == 'checkout.session.completed':
        session_id = data.get('id')
        metadata = data.get('metadata', {})
        user_id = metadata.get('user_id')
        payment_type = metadata.get('payment_type')
        
        if user_id and session_id:
            # Update payment status
            await db.execute(
                update(Payment)
                .where(Payment.stripe_session_id == session_id)
                .values(status="completed")
            )
            
            # Update user based on payment type
            if payment_type == 'premium_upgrade':
                # Upgrade user to premium
                await db.execute(
                    update(User)
                    .where(User.id == int(user_id))
                    .values(is_premium=True)
                )
            elif payment_type == 'additional_quotes':
                # Add additional quotes (assuming 10 quotes for 19.99€)
                amount = float(metadata.get('amount', 19.99))
                additional_quotes = 10 if amount >= 19.99 else 5
                
                await db.execute(
                    update(User)
                    .where(User.id == int(user_id))
                    .values(additional_quotes=User.additional_quotes + additional_quotes)
                )
            
            await db.commit()
    
    return {"status": "success"}

@router.get("/payments", response_model=list[PaymentResponse])
async def get_user_payments(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get payment history for current user"""
    
    result = await db.execute(
        select(Payment)
        .where(Payment.user_id == current_user.id)
        .order_by(Payment.created_at.desc())
    )
    payments = result.scalars().all()
    
    return payments





// Relative Path: src\routes\quotes.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, func
from sqlalchemy.orm import selectinload
from typing import List, Optional
from datetime import datetime
import uuid

from src.core.database import get_db
from src.routes.auth import get_current_user
from src.models.models import User, Quote, QuoteItem
from src.schemas.schemas import (
    QuoteCreate, QuoteUpdate, QuoteResponse, QuoteItemCreate, 
    SuccessResponse, ErrorResponse, GenerateQuoteAIRequest
)
from src.services.ai_service import AIService

router = APIRouter()
ai_service = AIService()

def generate_quote_number() -> str:
    """Generate unique quote number"""
    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    return f"KV-{timestamp}"

async def check_user_quota(user: User, db: AsyncSession) -> bool:
    """Check if user can create a new quote"""
    if user.is_premium:
        return True
    
    # Check free tier quota (3 per month)
    if user.quotes_this_month >= 3:
        # Check additional quotes
        if user.additional_quotes > 0:
            # Deduct from additional quotes
            await db.execute(
                update(User)
                .where(User.id == user.id)
                .values(additional_quotes=User.additional_quotes - 1)
            )
            await db.commit()
            return True
        return False
    
    # User hasn't reached monthly limit, increment counter
    await db.execute(
        update(User)
        .where(User.id == user.id)
        .values(quotes_this_month=User.quotes_this_month + 1)
    )
    await db.commit()
    return True

@router.get("/", response_model=List[QuoteResponse])
async def get_quotes(
    status_filter: Optional[str] = None,
    limit: int = 50,
    offset: int = 0,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get all quotes for current user"""
    
    query = select(Quote).where(Quote.user_id == current_user.id)
    
    if status_filter:
        query = query.where(Quote.status == status_filter)
    
    query = query.options(selectinload(Quote.quote_items)).order_by(Quote.created_at.desc()).limit(limit).offset(offset)
    
    result = await db.execute(query)
    quotes = result.scalars().all()
    
    return quotes

@router.post("/", response_model=QuoteResponse)
async def create_quote(
    quote_data: QuoteCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Create a new quote"""
    
    # Check user quota
    # if not await check_user_quota(current_user, db):
    #     raise HTTPException(
    #         status_code=status.HTTP_403_FORBIDDEN,
    #         detail="Quote limit reached. Please upgrade to premium or purchase additional quotes."
    #     )
    
    # Create quote
    quote_number = generate_quote_number()
    
    quote = Quote(
        quote_number=quote_number,
        user_id=current_user.id,
        customer_name=quote_data.customer_name,
        customer_email=quote_data.customer_email,
        customer_phone=quote_data.customer_phone,
        customer_address=quote_data.customer_address,
        project_title=quote_data.project_title,
        project_description=quote_data.project_description,
        status="draft",
        ai_processing_status="pending"
    )
    
    db.add(quote)
    await db.flush()  # This will get us the quote.id without committing
    
    # Add quote items
    total_amount = 0.0
    for item_data in quote_data.quote_items:
        quote_item = QuoteItem(
            quote_id=quote.id,
            position=item_data.position,
            description=item_data.description,
            quantity=item_data.quantity,
            unit=item_data.unit,
            unit_price=item_data.unit_price,
            total_price=item_data.total_price,
            room_name=item_data.room_name,
            area_sqm=item_data.area_sqm,
            work_type=item_data.work_type
        )
        db.add(quote_item)
        total_amount += item_data.total_price
    
    # Update quote with total amount
    quote.total_amount = total_amount
    quote.ai_processing_status = "completed"
    
    await db.commit()
    
    # Load the complete quote with items
    result = await db.execute(
        select(Quote)
        .where(Quote.id == quote.id)
        .options(selectinload(Quote.quote_items))
    )
    quote = result.scalar_one()
    
    return quote

@router.get("/{quote_id}", response_model=QuoteResponse)
async def get_quote(
    quote_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get specific quote"""
    
    result = await db.execute(
        select(Quote)
        .where(Quote.id == quote_id)
        .where(Quote.user_id == current_user.id)
    )
    quote = result.scalar_one_or_none()
    
    if not quote:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Quote not found"
        )
    
    # Load quote items
    items_result = await db.execute(
        select(QuoteItem)
        .where(QuoteItem.quote_id == quote.id)
        .order_by(QuoteItem.position)
    )
    quote.quote_items = items_result.scalars().all()
    
    return quote

@router.put("/{quote_id}", response_model=QuoteResponse)
async def update_quote(
    quote_id: int,
    quote_update: QuoteUpdate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Update a quote"""
    
    result = await db.execute(
        select(Quote)
        .where(Quote.id == quote_id)
        .where(Quote.user_id == current_user.id)
    )
    quote = result.scalar_one_or_none()
    
    if not quote:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Quote not found"
        )
    
    # Update quote
    update_data = quote_update.model_dump(exclude_unset=True)
    if update_data:
        await db.execute(
            update(Quote)
            .where(Quote.id == quote_id)
            .values(**update_data)
        )
        await db.commit()
        await db.refresh(quote)
    
    # Load quote items
    items_result = await db.execute(
        select(QuoteItem)
        .where(QuoteItem.quote_id == quote.id)
        .order_by(QuoteItem.position)
    )
    quote.quote_items = items_result.scalars().all()
    
    return quote

@router.delete("/{quote_id}", response_model=SuccessResponse)
async def delete_quote(
    quote_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Delete a quote"""
    
    result = await db.execute(
        select(Quote)
        .where(Quote.id == quote_id)
        .where(Quote.user_id == current_user.id)
    )
    quote = result.scalar_one_or_none()
    
    if not quote:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Quote not found"
        )
    
    await db.delete(quote)
    await db.commit()
    
    return SuccessResponse(message="Quote deleted successfully")

@router.post("/{quote_id}/generate-ai", response_model=QuoteResponse)
async def generate_quote_with_ai(
    quote_id: int,
    request: GenerateQuoteAIRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Generate quote items using AI based on project description"""
    
    result = await db.execute(
        select(Quote)
        .where(Quote.id == quote_id)
        .where(Quote.user_id == current_user.id)
    )
    quote = result.scalar_one_or_none()
    
    if not quote:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Quote not found"
        )
    
    try:
        # Update processing status
        await db.execute(
            update(Quote)
            .where(Quote.id == quote_id)
            .values(ai_processing_status="processing")
        )
        await db.commit()
        
        # Analyze with AI
        analysis = await ai_service.analyze_project_description(
            description=request.project_description, 
            context="quote_generation"
        )
        
        # Clear existing quote items
        existing_items = (await db.execute(
            select(QuoteItem).where(QuoteItem.quote_id == quote_id)
        )).scalars().all()
        
        for item in existing_items:
            await db.delete(item)
        
        # Create new quote items from AI suggestions
        total_amount = 0.0
        suggested_items = analysis.get("suggested_items", [])
        
        for i, item_data in enumerate(suggested_items, 1):
            quote_item = QuoteItem(
                quote_id=quote.id,
                position=i,
                description=item_data.get("description", ""),
                quantity=item_data.get("quantity", 1),
                unit=item_data.get("unit", "Stk"),
                unit_price=item_data.get("unit_price", 0),
                total_price=item_data.get("total_price", 0),
                work_type=item_data.get("work_type", "")
            )
            db.add(quote_item)
            total_amount += quote_item.total_price
        
        # Update quote
        await db.execute(
            update(Quote)
            .where(Quote.id == quote_id)
            .values(
                total_amount=total_amount,
                ai_processing_status="completed",
                project_description=request.project_description
            )
        )
        
        await db.commit()
        
        # Load the complete quote with items
        result = await db.execute(
            select(Quote)
            .where(Quote.id == quote.id)
            .options(selectinload(Quote.quote_items))
        )
        quote = result.scalar_one()
        
        return quote
        
    except Exception as e:
        # Update status to failed
        await db.execute(
            update(Quote)
            .where(Quote.id == quote_id)
            .values(ai_processing_status="failed")
        )
        await db.commit()
        
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"AI quote generation failed: {str(e)}"
        )

@router.post("/{quote_id}/duplicate", response_model=QuoteResponse)
async def duplicate_quote(
    quote_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Duplicate an existing quote"""
    
    # Check user quota
    # if not await check_user_quota(current_user, db):
    #     raise HTTPException(
    #         status_code=status.HTTP_403_FORBIDDEN,
    #         detail="Quote limit reached. Please upgrade to premium or purchase additional quotes."
    #     )
    
    result = await db.execute(
        select(Quote)
        .where(Quote.id == quote_id)
        .where(Quote.user_id == current_user.id)
    )
    original_quote = result.scalar_one_or_none()
    
    if not original_quote:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Quote not found"
        )
    
    # Create new quote
    new_quote_number = generate_quote_number()
    
    new_quote = Quote(
        quote_number=new_quote_number,
        user_id=current_user.id,
        customer_name=f"Kopie - {original_quote.customer_name}",
        customer_email=original_quote.customer_email,
        customer_phone=original_quote.customer_phone,
        customer_address=original_quote.customer_address,
        project_title=f"Kopie - {original_quote.project_title}",
        project_description=original_quote.project_description,
        total_amount=original_quote.total_amount,
        labor_hours=original_quote.labor_hours,
        hourly_rate=original_quote.hourly_rate,
        material_cost=original_quote.material_cost,
        additional_costs=original_quote.additional_costs,
        status="draft",
        ai_processing_status="completed"
    )
    
    db.add(new_quote)
    await db.commit()
    await db.refresh(new_quote)
    
    # Copy quote items
    items_result = await db.execute(
        select(QuoteItem)
        .where(QuoteItem.quote_id == quote_id)
        .order_by(QuoteItem.position)
    )
    original_items = items_result.scalars().all()
    
    for original_item in original_items:
        new_item = QuoteItem(
            quote_id=new_quote.id,
            position=original_item.position,
            description=original_item.description,
            quantity=original_item.quantity,
            unit=original_item.unit,
            unit_price=original_item.unit_price,
            total_price=original_item.total_price,
            room_name=original_item.room_name,
            area_sqm=original_item.area_sqm,
            work_type=original_item.work_type
        )
        db.add(new_item)
    
    await db.commit()
    
    # Load new quote with items
    items_result = await db.execute(
        select(QuoteItem)
        .where(QuoteItem.quote_id == new_quote.id)
        .order_by(QuoteItem.position)
    )
    new_quote.quote_items = items_result.scalars().all()
    
    return new_quote





// Relative Path: src\routes\user.py
from flask import Blueprint, jsonify, request
from src.models.models import User, db
from datetime import datetime

user_bp = Blueprint('user', __name__)

@user_bp.route('/users', methods=['GET'])
def get_users():
    """Get all users (admin only)"""
    try:
        users = User.query.all()
        return jsonify([user.to_dict() for user in users])
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@user_bp.route('/users', methods=['POST'])
def create_user():
    """Create a new user"""
    try:
        data = request.json
        
        # Validate required fields
        required_fields = ['email', 'username']
        for field in required_fields:
            if not data.get(field):
                return jsonify({'error': f'Missing required field: {field}'}), 400
        
        # Check if user already exists
        existing_user = User.query.filter_by(email=data['email']).first()
        if existing_user:
            return jsonify({'error': 'User with this email already exists'}), 400
        
        user = User(
            email=data['email'],
            username=data['username'],
            company_name=data.get('company_name'),
            phone=data.get('phone'),
            address=data.get('address'),
            supabase_user_id=data.get('supabase_user_id')
        )
        
        db.session.add(user)
        db.session.commit()
        
        return jsonify(user.to_dict()), 201
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@user_bp.route('/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
    """Get a specific user"""
    try:
        user = User.query.get_or_404(user_id)
        return jsonify(user.to_dict())
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@user_bp.route('/users/by-email/<email>', methods=['GET'])
def get_user_by_email(email):
    """Get user by email"""
    try:
        user = User.query.filter_by(email=email).first()
        if not user:
            return jsonify({'error': 'User not found'}), 404
        return jsonify(user.to_dict())
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@user_bp.route('/users/by-supabase-id/<supabase_id>', methods=['GET'])
def get_user_by_supabase_id(supabase_id):
    """Get user by Supabase user ID"""
    try:
        user = User.query.filter_by(supabase_user_id=supabase_id).first()
        if not user:
            return jsonify({'error': 'User not found'}), 404
        return jsonify(user.to_dict())
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@user_bp.route('/users/<int:user_id>', methods=['PUT'])
def update_user(user_id):
    """Update a user"""
    try:
        user = User.query.get_or_404(user_id)
        data = request.json
        
        # Update fields
        updatable_fields = ['username', 'company_name', 'phone', 'address']
        for field in updatable_fields:
            if field in data:
                setattr(user, field, data[field])
        
        user.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify(user.to_dict())
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@user_bp.route('/users/<int:user_id>', methods=['DELETE'])
def delete_user(user_id):
    """Delete a user"""
    try:
        user = User.query.get_or_404(user_id)
        db.session.delete(user)
        db.session.commit()
        return '', 204
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@user_bp.route('/users/<int:user_id>/increment-quotes', methods=['POST'])
def increment_user_quotes(user_id):
    """Increment user's monthly quote counter"""
    try:
        user = User.query.get_or_404(user_id)
        user.quotes_this_month += 1
        user.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({
            'quotes_this_month': user.quotes_this_month,
            'can_create_more': user.is_premium or user.quotes_this_month < 3
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@user_bp.route('/users/<int:user_id>/reset-monthly-quotes', methods=['POST'])
def reset_monthly_quotes(user_id):
    """Reset user's monthly quote counter (admin only)"""
    try:
        user = User.query.get_or_404(user_id)
        user.quotes_this_month = 0
        user.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({'message': 'Monthly quotes reset', 'quotes_this_month': 0})
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500





// Relative Path: src\routes\users.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update
from typing import List

from src.core.database import get_db
from src.routes.auth import get_current_user
from src.models.models import User
from src.schemas.schemas import UserResponse, UserUpdate, SuccessResponse

router = APIRouter()

@router.get("/profile", response_model=UserResponse)
async def get_user_profile(current_user: User = Depends(get_current_user)):
    """Get current user profile"""
    return current_user

@router.put("/profile", response_model=UserResponse)
async def update_user_profile(
    user_update: UserUpdate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Update current user profile"""
    
    # Check if username/email is already taken by another user
    if user_update.username or user_update.email:
        conditions = []
        if user_update.username:
            conditions.append(User.username == user_update.username)
        if user_update.email:
            conditions.append(User.email == user_update.email)
        
        result = await db.execute(
            select(User).where(
                (conditions[0] if len(conditions) == 1 else conditions[0] | conditions[1]) &
                (User.id != current_user.id)
            )
        )
        existing_user = result.scalar_one_or_none()
        
        if existing_user:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Username or email already taken"
            )
    
    # Update user
    update_data = user_update.model_dump(exclude_unset=True)
    if update_data:
        await db.execute(
            update(User).where(User.id == current_user.id).values(**update_data)
        )
        await db.commit()
        
        # Refresh user data
        await db.refresh(current_user)
    
    return current_user

@router.delete("/profile", response_model=SuccessResponse)
async def delete_user_account(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Delete current user account"""
    
    await db.delete(current_user)
    await db.commit()
    
    return SuccessResponse(message="Account deleted successfully")

@router.get("/quota", response_model=dict)
async def get_user_quota(current_user: User = Depends(get_current_user)):
    """Get current user quota information"""
    
    total_available = 3  # Free tier
    if current_user.is_premium:
        total_available = -1  # Unlimited
    
    quotes_remaining = max(0, total_available - current_user.quotes_this_month) if total_available > 0 else -1
    
    return {
        "is_premium": current_user.is_premium,
        "unlimited": current_user.is_premium,
        "total_available": total_available,
        "quotes_used": current_user.quotes_this_month,
        "quotes_remaining": quotes_remaining,
        "additional_quotes": current_user.additional_quotes
    }





// Relative Path: src\routes\__init__.py
# Routes package





// Relative Path: src\schemas\schemas.py
from pydantic import BaseModel, EmailStr, Field
from typing import Optional, List, Dict, Any
from datetime import datetime
from enum import Enum

# User Schemas
class UserBase(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    email: EmailStr
    company_name: Optional[str] = None
    phone: Optional[str] = None
    address: Optional[str] = None

class UserCreate(UserBase):
    password: str = Field(..., min_length=6)

class UserUpdate(BaseModel):
    username: Optional[str] = None
    email: Optional[EmailStr] = None
    company_name: Optional[str] = None
    phone: Optional[str] = None
    address: Optional[str] = None

class UserResponse(UserBase):
    id: int
    is_premium: bool
    premium_until: Optional[datetime]
    quotes_this_month: int
    additional_quotes: int
    created_at: datetime
    
    class Config:
        from_attributes = True

# Auth schemas
class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

class LoginRequest(BaseModel):
    email: EmailStr
    password: str

# Quote schemas
class QuoteItemBase(BaseModel):
    position: int
    description: str
    quantity: float
    unit: str
    unit_price: float
    total_price: float
    room_name: Optional[str] = None
    area_sqm: Optional[float] = None
    work_type: Optional[str] = None

class QuoteItemCreate(QuoteItemBase):
    pass

class QuoteItemResponse(QuoteItemBase):
    id: int
    created_at: datetime
    
    class Config:
        from_attributes = True

class QuoteBase(BaseModel):
    customer_name: str = Field(..., min_length=1, max_length=100)
    customer_email: Optional[EmailStr] = None
    customer_phone: Optional[str] = None
    customer_address: Optional[str] = None
    project_title: str = Field(..., min_length=1, max_length=200)
    project_description: Optional[str] = None

class QuoteCreate(QuoteBase):
    quote_items: List[QuoteItemCreate] = []

class QuoteUpdate(BaseModel):
    customer_name: Optional[str] = None
    customer_email: Optional[EmailStr] = None
    customer_phone: Optional[str] = None
    customer_address: Optional[str] = None
    project_title: Optional[str] = None
    project_description: Optional[str] = None
    status: Optional[str] = None

class QuoteResponse(QuoteBase):
    id: int
    quote_number: str
    total_amount: Optional[float]
    labor_hours: Optional[float]
    hourly_rate: Optional[float]
    material_cost: Optional[float]
    additional_costs: Optional[float]
    status: str
    ai_processing_status: str
    created_at: datetime
    updated_at: datetime
    quote_items: List[QuoteItemResponse] = []
    
    class Config:
        from_attributes = True

# AI schemas
class AIAnalysisRequest(BaseModel):
    input_text: str = Field(..., min_length=1)
    context: Optional[str] = "initial_input"

class AIAnalysisResponse(BaseModel):
    success: bool
    confidence: float
    extracted_data: dict
    questions: List[str]
    suggested_items: List[dict]

# Document schemas
class DocumentResponse(BaseModel):
    id: int
    filename: str
    original_filename: str
    file_size: Optional[int]
    mime_type: Optional[str]
    extracted_text: Optional[str]
    analysis_result: Optional[str]
    processing_status: str
    created_at: datetime
    
    class Config:
        from_attributes = True

# Payment schemas
class PaymentCreate(BaseModel):
    amount: float
    payment_type: str
    description: Optional[str] = None

class PaymentResponse(BaseModel):
    id: int
    amount: float
    currency: str
    status: str
    payment_type: str
    description: Optional[str]
    created_at: datetime
    
    class Config:
        from_attributes = True

# Generic response schemas
class SuccessResponse(BaseModel):
    success: bool = True
    message: str

class ErrorResponse(BaseModel):
    success: bool = False
    error: str
    detail: Optional[str] = None


# AI Schemas
class AIAnalysisRequest(BaseModel):
    description: str
    context: Optional[str] = "initial_input"

class AIQuestion(BaseModel):
    id: str
    question: str
    type: str  # "multiple_choice", "text", "number"
    options: Optional[List[str]] = None

class AIAnalysisResponse(BaseModel):
    analysis: Dict[str, Any]
    questions: List[AIQuestion]
    suggestions: List[str]
    success: bool = True

class AIFollowUpRequest(BaseModel):
    message: str
    conversation_history: List[Dict[str, Any]] = []

class AIQuestionResponse(BaseModel):
    response: str
    needs_more_info: bool
    suggested_questions: List[str] = []
    success: bool = True

class AIQuoteGenerationRequest(BaseModel):
    project_data: Dict[str, Any]
    answers: List[Dict[str, Any]]

class GenerateQuoteAIRequest(BaseModel):
    project_description: str = Field(..., min_length=1)

class AIQuoteItem(BaseModel):
    description: str
    quantity: float
    unit: str
    unit_price: float
    total_price: float
    category: str

class AIQuoteData(BaseModel):
    project_title: str
    total_amount: float
    labor_hours: float
    hourly_rate: float
    material_cost: float
    additional_costs: float

class AIQuoteGenerationResponse(BaseModel):
    quote: AIQuoteData
    items: List[AIQuoteItem]
    notes: str
    recommendations: List[str]
    success: bool = True





// Relative Path: src\schemas\__init__.py
# Schemas package





// Relative Path: src\services\ai_service.py
import os
import openai
import json
import asyncio
from typing import Dict, List, Optional, Any
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class AIService:
    def __init__(self):
        api_key = os.getenv('OPENAI_API_KEY')
        if api_key and api_key != 'test_key_placeholder' and api_key.startswith('sk-'):
            self.client = openai.AsyncOpenAI(api_key=api_key)
            self.model = "gpt-4o"
            self.enabled = True
            logger.info("OpenAI client initialized successfully")
        else:
            self.client = None
            self.model = None
            self.enabled = False
            logger.warning("OpenAI API key not configured, using mock responses")

    async def analyze_project_description(self, description: str, context: str = "initial_input") -> Dict:
        """Analyze project description and generate intelligent follow-up questions"""
        
        if not self.enabled:
            return self._get_mock_analysis_response(description)
        
        try:
            system_prompt = """Du bist ein erfahrener Maler-Experte und KI-Assistent für Kostenvoranschläge. 
            Deine Aufgabe ist es, Projektbeschreibungen zu analysieren und intelligente Rückfragen zu stellen, 
            um alle notwendigen Informationen für einen präzisen Kostenvoranschlag zu sammeln.

            Analysiere die Projektbeschreibung und generiere 2-4 relevante Rückfragen als Multiple-Choice oder 
            offene Fragen. Fokussiere dich auf:
            - Fehlende technische Details (Fläche, Höhe, Zustand)
            - Materialwünsche und Qualität
            - Zeitrahmen und Zugänglichkeit
            - Vorarbeiten und Besonderheiten

            Antworte im JSON-Format:
            {
                "analysis": {
                    "project_type": "string",
                    "estimated_area": "number or null",
                    "complexity": "low|medium|high",
                    "missing_info": ["list of missing information"]
                },
                "questions": [
                    {
                        "id": "unique_id",
                        "question": "Frage-Text",
                        "type": "multiple_choice|text|number",
                        "options": ["option1", "option2"] // nur bei multiple_choice
                    }
                ],
                "suggestions": ["hilfreiche Tipps für den Kunden"]
            }"""

            user_prompt = f"""Projektbeschreibung: {description}

            Kontext: {context}
            
            Bitte analysiere diese Beschreibung und stelle intelligente Rückfragen."""

            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=0.7,
                max_tokens=1500
            )

            content = response.choices[0].message.content
            
            # Parse JSON response
            try:
                # remove '''json ''' from content
                content = content.replace('```json', '').replace('```', '')
                print(content)
                result = json.loads(content)
                return result
            except json.JSONDecodeError:
                logger.error(f"Failed to parse OpenAI JSON response: {content}")
                return self._get_mock_analysis_response(description)

        except Exception as e:
            logger.error(f"OpenAI API error: {str(e)}")
            return self._get_mock_analysis_response(description)

    async def process_answers_and_generate_quote(self, 
                                                project_data: Dict, 
                                                answers: List[Dict]) -> Dict:
        """Process user answers and generate a detailed quote"""
        
        if not self.enabled:
            return self._get_mock_quote_response(project_data, answers)
        
        try:
            system_prompt = """Du bist ein erfahrener Maler-Meister und erstellst präzise Kostenvoranschläge.
            Basierend auf der Projektbeschreibung und den Antworten des Kunden, erstelle einen detaillierten 
            Kostenvoranschlag mit realistischen Preisen für den deutschen Markt.

            Berücksichtige:
            - Materialkosten (Farbe, Grundierung, Werkzeug)
            - Arbeitszeit (Vorbereitung, Streichen, Nacharbeiten)
            - Schwierigkeitsgrad und Zugänglichkeit
            - Regionale Preisunterschiede (Deutschland)
            - Mehrwertsteuer (19%)

            Antworte im JSON-Format:
            {
                "quote": {
                    "project_title": "string",
                    "total_amount": number,
                    "labor_hours": number,
                    "hourly_rate": number,
                    "material_cost": number,
                    "additional_costs": number
                },
                "items": [
                    {
                        "description": "string",
                        "quantity": number,
                        "unit": "string",
                        "unit_price": number,
                        "total_price": number,
                        "category": "labor|material|additional"
                    }
                ],
                "notes": "string",
                "recommendations": ["string"]
            }"""

            user_prompt = f"""Projektdaten:
            {json.dumps(project_data, indent=2, ensure_ascii=False)}

            Kundenantworten:
            {json.dumps(answers, indent=2, ensure_ascii=False)}

            Erstelle einen detaillierten Kostenvoranschlag."""

            response = await self.client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=0.3,
                max_tokens=2000
            )

            content = response.choices[0].message.content
            
            try:
                result = json.loads(content)
                return result
            except json.JSONDecodeError:
                logger.error(f"Failed to parse OpenAI quote JSON: {content}")
                return self._get_mock_quote_response(project_data, answers)

        except Exception as e:
            logger.error(f"OpenAI API error in quote generation: {str(e)}")
            return self._get_mock_quote_response(project_data, answers)

    async def ask_follow_up_question(self, conversation_history: List[Dict], 
                                   user_message: str) -> Dict:
        """Handle follow-up questions in the conversation"""
        
        if not self.enabled:
            return self._get_mock_followup_response(user_message)
        
        try:
            system_prompt = """Du bist ein hilfsreicher KI-Assistent für Maler-Kostenvoranschläge.
            Beantworte Fragen des Kunden höflich und kompetent. Wenn zusätzliche Informationen 
            benötigt werden, stelle gezielte Nachfragen.

            Antworte im JSON-Format:
            {
                "response": "string",
                "needs_more_info": boolean,
                "suggested_questions": ["string"] // optional
            }"""

            # Build conversation context
            messages = [{"role": "system", "content": system_prompt}]
            
            for msg in conversation_history[-5:]:  # Last 5 messages for context
                messages.append({
                    "role": msg.get("role", "user"),
                    "content": msg.get("content", "")
                })
            
            messages.append({"role": "user", "content": user_message})

            response = await self.client.chat.completions.create(
                model=self.model,
                messages=messages,
                temperature=0.7,
                max_tokens=800
            )

            content = response.choices[0].message.content
            
            try:
                result = json.loads(content)
                return result
            except json.JSONDecodeError:
                # Fallback to simple text response
                return {
                    "response": content,
                    "needs_more_info": False,
                    "suggested_questions": []
                }

        except Exception as e:
            logger.error(f"OpenAI API error in follow-up: {str(e)}")
            return self._get_mock_followup_response(user_message)

    def _get_mock_analysis_response(self, description: str) -> Dict:
        """Mock response for testing without OpenAI API"""
        return {
            "analysis": {
                "project_type": "Innenraumstreichung",
                "estimated_area": 25,
                "complexity": "medium",
                "missing_info": ["Genaue Quadratmeter", "Farbwunsch", "Vorarbeiten"]
            },
            "questions": [
                {
                    "id": "area_size",
                    "question": "Wie groß ist die zu streichende Fläche in Quadratmetern?",
                    "type": "multiple_choice",
                    "options": ["Unter 20m²", "20-40m²", "40-60m²", "Über 60m²"]
                },
                {
                    "id": "paint_type",
                    "question": "Welche Art von Farbe soll verwendet werden?",
                    "type": "multiple_choice",
                    "options": ["Standard-Wandfarbe", "Premium-Farbe", "Spezialfarbe", "Kundenwunsch"]
                },
                {
                    "id": "prep_work",
                    "question": "Sind Vorarbeiten nötig (z.B. Spachteln, Grundierung)?",
                    "type": "multiple_choice",
                    "options": ["Ja, umfangreich", "Ja, minimal", "Nein", "Unsicher"]
                }
            ],
            "suggestions": [
                "Vielen Dank für die Information. Können Sie mir noch sagen, ob spezielle Vorbereitungen nötig sind?",
                "Kleinere Ausbesserungen können den Preis beeinflussen."
            ]
        }

    def _get_mock_quote_response(self, project_data: Dict, answers: List[Dict]) -> Dict:
        """Mock quote response for testing"""
        return {
            "quote": {
                "project_title": project_data.get("project_title", "Malerarbeiten"),
                "total_amount": 850.50,
                "labor_hours": 12,
                "hourly_rate": 45.0,
                "material_cost": 180.50,
                "additional_costs": 130.0
            },
            "items": [
                {
                    "description": "Wände und Decke streichen",
                    "quantity": 25,
                    "unit": "m²",
                    "unit_price": 18.0,
                    "total_price": 450.0,
                    "category": "labor"
                },
                {
                    "description": "Premium-Wandfarbe weiß",
                    "quantity": 3,
                    "unit": "Liter",
                    "unit_price": 35.0,
                    "total_price": 105.0,
                    "category": "material"
                },
                {
                    "description": "Grundierung und Spachtelmasse",
                    "quantity": 1,
                    "unit": "Pauschal",
                    "unit_price": 75.50,
                    "total_price": 75.50,
                    "category": "material"
                },
                {
                    "description": "Anfahrt und Entsorgung",
                    "quantity": 1,
                    "unit": "Pauschal",
                    "unit_price": 130.0,
                    "total_price": 130.0,
                    "category": "additional"
                }
            ],
            "notes": "Alle Preise inkl. 19% MwSt. Gültig für 30 Tage.",
            "recommendations": [
                "Empfehlung: Premium-Farbe für bessere Deckkraft",
                "Tipp: Möbel sollten abgedeckt oder ausgeräumt werden"
            ]
        }

    def _get_mock_followup_response(self, user_message: str) -> Dict:
        """Mock follow-up response"""
        return {
            "response": "Vielen Dank für die Information. Können Sie mir noch sagen, ob spezielle Vorbereitungen nötig sind?",
            "needs_more_info": True,
            "suggested_questions": [
                "Kleinere Ausbesserungen können den Preis beeinflussen."
            ]
        }





// Relative Path: src\services\pdf_service.py
import os
import smtplib
import requests
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication
from datetime import datetime
from jinja2 import Template
import json

class PDFService:
    def __init__(self):
        self.craftmypdf_api_key = os.getenv('CRAFTMYPDF_API_KEY')
        self.craftmypdf_template_id = os.getenv('CRAFTMYPDF_TEMPLATE_ID')
        self.base_url = 'https://api.craftmypdf.com/v1'
    
    def generate_quote_pdf(self, quote_data):
        """
        Generate PDF using CraftMyPDF API
        """
        try:
            # Prepare data for PDF template
            pdf_data = self._prepare_pdf_data(quote_data)
            
            # Make API request to CraftMyPDF
            headers = {
                'X-API-KEY': self.craftmypdf_api_key,
                'Content-Type': 'application/json'
            }
            
            payload = {
                'template_id': self.craftmypdf_template_id,
                'data': pdf_data,
                'export_type': 'pdf',
                'expiration': 60  # PDF expires in 60 minutes
            }
            
            response = requests.post(
                f'{self.base_url}/create',
                headers=headers,
                json=payload
            )
            
            if response.status_code == 200:
                result = response.json()
                return {
                    'success': True,
                    'pdf_url': result.get('file'),
                    'download_url': result.get('file'),
                    'expires_at': result.get('expires_at')
                }
            else:
                return {
                    'success': False,
                    'error': f'PDF generation failed: {response.text}'
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': f'PDF generation error: {str(e)}'
            }
    
    def _prepare_pdf_data(self, quote_data):
        """
        Prepare quote data for PDF template
        """
        # Format currency
        def format_currency(amount):
            return f"{amount:,.2f} €".replace(',', '.')
        
        # Calculate totals
        subtotal = sum(item['total_price'] for item in quote_data['quote_items'])
        vat_rate = 0.19  # 19% VAT
        vat_amount = subtotal * vat_rate
        total_amount = subtotal + vat_amount
        
        return {
            # Quote information
            'quote_number': quote_data['quote_number'],
            'quote_date': datetime.now().strftime('%d.%m.%Y'),
            'valid_until': (datetime.now().replace(day=datetime.now().day + 30)).strftime('%d.%m.%Y'),
            
            # Customer information
            'customer_name': quote_data['customer_name'],
            'customer_email': quote_data.get('customer_email', ''),
            'customer_phone': quote_data.get('customer_phone', ''),
            'customer_address': quote_data.get('customer_address', ''),
            
            # Project information
            'project_title': quote_data['project_title'],
            'project_description': quote_data.get('project_description', ''),
            
            # Quote items
            'quote_items': [
                {
                    'position': item['position'],
                    'description': item['description'],
                    'quantity': f"{item['quantity']:.1f}",
                    'unit': item['unit'],
                    'unit_price': format_currency(item['unit_price']),
                    'total_price': format_currency(item['total_price']),
                    'room_name': item.get('room_name', '')
                }
                for item in quote_data['quote_items']
            ],
            
            # Totals
            'subtotal': format_currency(subtotal),
            'vat_rate': f"{vat_rate * 100:.0f}%",
            'vat_amount': format_currency(vat_amount),
            'total_amount': format_currency(total_amount),
            
            # Company information (from environment or config)
            'company_name': os.getenv('COMPANY_NAME', 'Ihr Malerbetrieb'),
            'company_address': os.getenv('COMPANY_ADDRESS', 'Musterstraße 123\n12345 Musterstadt'),
            'company_phone': os.getenv('COMPANY_PHONE', '+49 123 456789'),
            'company_email': os.getenv('COMPANY_EMAIL', 'info@malerbetrieb.de'),
            'company_website': os.getenv('COMPANY_WEBSITE', 'www.malerbetrieb.de'),
            'company_tax_number': os.getenv('COMPANY_TAX_NUMBER', 'DE123456789'),
            
            # Terms and conditions
            'payment_terms': '30 Tage netto',
            'warranty_terms': '2 Jahre Gewährleistung auf Malerarbeiten',
            'notes': 'Alle Preise verstehen sich zzgl. der gesetzlichen Mehrwertsteuer.'
        }

class EmailService:
    def __init__(self):
        self.smtp_server = os.getenv('SMTP_SERVER', 'smtp.gmail.com')
        self.smtp_port = int(os.getenv('SMTP_PORT', '587'))
        self.smtp_username = os.getenv('SMTP_USERNAME')
        self.smtp_password = os.getenv('SMTP_PASSWORD')
        self.from_email = os.getenv('FROM_EMAIL', self.smtp_username)
        self.from_name = os.getenv('FROM_NAME', 'Ihr Malerbetrieb')
    
    def send_quote_email(self, quote_data, pdf_url=None):
        """
        Send quote email to customer
        """
        try:
            # Create message
            msg = MIMEMultipart()
            msg['From'] = f"{self.from_name} <{self.from_email}>"
            msg['To'] = quote_data['customer_email']
            msg['Subject'] = f"Kostenvoranschlag {quote_data['quote_number']} - {quote_data['project_title']}"
            
            # Email body
            email_body = self._generate_email_body(quote_data)
            msg.attach(MIMEText(email_body, 'html', 'utf-8'))
            
            # Attach PDF if available
            if pdf_url:
                try:
                    pdf_response = requests.get(pdf_url)
                    if pdf_response.status_code == 200:
                        pdf_attachment = MIMEApplication(pdf_response.content, _subtype='pdf')
                        pdf_attachment.add_header(
                            'Content-Disposition', 
                            'attachment', 
                            filename=f"{quote_data['quote_number']}.pdf"
                        )
                        msg.attach(pdf_attachment)
                except Exception as e:
                    print(f"Warning: Could not attach PDF: {e}")
            
            # Send email
            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
                server.starttls()
                server.login(self.smtp_username, self.smtp_password)
                server.send_message(msg)
            
            return {
                'success': True,
                'message': 'Email sent successfully'
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': f'Email sending failed: {str(e)}'
            }
    
    def _generate_email_body(self, quote_data):
        """
        Generate HTML email body
        """
        template_str = """
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <style>
                body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
                .header { background-color: #f8f9fa; padding: 20px; border-radius: 5px; margin-bottom: 20px; }
                .content { margin: 20px 0; }
                .footer { margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee; font-size: 12px; color: #666; }
                .highlight { background-color: #e3f2fd; padding: 15px; border-radius: 5px; margin: 15px 0; }
                .button { 
                    display: inline-block; 
                    padding: 12px 24px; 
                    background-color: #2196f3; 
                    color: white; 
                    text-decoration: none; 
                    border-radius: 5px; 
                    margin: 10px 0;
                }
            </style>
        </head>
        <body>
            <div class="header">
                <h2>Kostenvoranschlag {{ quote_number }}</h2>
                <p>{{ project_title }}</p>
            </div>
            
            <div class="content">
                <p>Sehr geehrte/r {{ customer_name }},</p>
                
                <p>vielen Dank für Ihre Anfrage. Gerne übersenden wir Ihnen hiermit unseren Kostenvoranschlag für das Projekt "{{ project_title }}".</p>
                
                <div class="highlight">
                    <h3>Projektdetails:</h3>
                    <ul>
                        <li><strong>Angebotsnummer:</strong> {{ quote_number }}</li>
                        <li><strong>Projekt:</strong> {{ project_title }}</li>
                        <li><strong>Gesamtsumme:</strong> {{ total_amount }} (inkl. MwSt.)</li>
                        <li><strong>Gültig bis:</strong> {{ valid_until }}</li>
                    </ul>
                </div>
                
                <p>Den detaillierten Kostenvoranschlag finden Sie im Anhang als PDF-Datei.</p>
                
                <p>Bei Fragen stehen wir Ihnen gerne zur Verfügung. Wir freuen uns auf Ihre Rückmeldung und die Zusammenarbeit mit Ihnen.</p>
                
                <p>Mit freundlichen Grüßen<br>
                {{ company_name }}</p>
            </div>
            
            <div class="footer">
                <p>{{ company_name }}<br>
                {{ company_address }}<br>
                Tel: {{ company_phone }}<br>
                E-Mail: {{ company_email }}</p>
                
                <p><small>Diese E-Mail wurde automatisch generiert. Bei Fragen antworten Sie bitte direkt auf diese E-Mail.</small></p>
            </div>
        </body>
        </html>
        """
        
        template = Template(template_str)
        
        # Calculate total amount
        subtotal = sum(item['total_price'] for item in quote_data['quote_items'])
        vat_amount = subtotal * 0.19
        total_amount = subtotal + vat_amount
        
        return template.render(
            quote_number=quote_data['quote_number'],
            customer_name=quote_data['customer_name'],
            project_title=quote_data['project_title'],
            total_amount=f"{total_amount:,.2f} €".replace(',', '.'),
            valid_until=(datetime.now().replace(day=datetime.now().day + 30)).strftime('%d.%m.%Y'),
            company_name=os.getenv('COMPANY_NAME', 'Ihr Malerbetrieb'),
            company_address=os.getenv('COMPANY_ADDRESS', 'Musterstraße 123, 12345 Musterstadt'),
            company_phone=os.getenv('COMPANY_PHONE', '+49 123 456789'),
            company_email=os.getenv('COMPANY_EMAIL', 'info@malerbetrieb.de')
        )

# Alternative: Simple PDF generation using reportlab (fallback)
class SimplePDFService:
    def __init__(self):
        pass
    
    def generate_simple_pdf(self, quote_data, output_path):
        """
        Generate simple PDF using reportlab as fallback
        """
        try:
            from reportlab.lib.pagesizes import A4
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib.units import cm
            from reportlab.lib import colors
            
            # Create PDF document
            doc = SimpleDocTemplate(output_path, pagesize=A4)
            styles = getSampleStyleSheet()
            story = []
            
            # Title
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=24,
                spaceAfter=30,
                textColor=colors.HexColor('#2196f3')
            )
            story.append(Paragraph("KOSTENVORANSCHLAG", title_style))
            story.append(Spacer(1, 20))
            
            # Quote info
            quote_info = f"""
            <b>Angebotsnummer:</b> {quote_data['quote_number']}<br/>
            <b>Datum:</b> {datetime.now().strftime('%d.%m.%Y')}<br/>
            <b>Projekt:</b> {quote_data['project_title']}<br/>
            """
            story.append(Paragraph(quote_info, styles['Normal']))
            story.append(Spacer(1, 20))
            
            # Customer info
            customer_info = f"""
            <b>Kunde:</b><br/>
            {quote_data['customer_name']}<br/>
            {quote_data.get('customer_address', '')}<br/>
            {quote_data.get('customer_email', '')}<br/>
            {quote_data.get('customer_phone', '')}
            """
            story.append(Paragraph(customer_info, styles['Normal']))
            story.append(Spacer(1, 30))
            
            # Quote items table
            table_data = [['Pos.', 'Beschreibung', 'Menge', 'Einheit', 'Einzelpreis', 'Gesamtpreis']]
            
            for item in quote_data['quote_items']:
                table_data.append([
                    str(item['position']),
                    item['description'],
                    f"{item['quantity']:.1f}",
                    item['unit'],
                    f"{item['unit_price']:.2f} €",
                    f"{item['total_price']:.2f} €"
                ])
            
            # Calculate totals
            subtotal = sum(item['total_price'] for item in quote_data['quote_items'])
            vat_amount = subtotal * 0.19
            total_amount = subtotal + vat_amount
            
            # Add totals
            table_data.append(['', '', '', '', 'Zwischensumme:', f"{subtotal:.2f} €"])
            table_data.append(['', '', '', '', 'MwSt. (19%):', f"{vat_amount:.2f} €"])
            table_data.append(['', '', '', '', 'Gesamtsumme:', f"{total_amount:.2f} €"])
            
            table = Table(table_data, colWidths=[1*cm, 6*cm, 2*cm, 2*cm, 3*cm, 3*cm])
            table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('FONTNAME', (0, -3), (-1, -1), 'Helvetica-Bold'),
                ('BACKGROUND', (0, -1), (-1, -1), colors.lightgrey),
            ]))
            
            story.append(table)
            story.append(Spacer(1, 30))
            
            # Terms
            terms = """
            <b>Zahlungsbedingungen:</b> 30 Tage netto<br/>
            <b>Gewährleistung:</b> 2 Jahre auf Malerarbeiten<br/>
            <b>Gültigkeit:</b> 30 Tage ab Angebotsdatum<br/><br/>
            Alle Preise verstehen sich zzgl. der gesetzlichen Mehrwertsteuer.
            """
            story.append(Paragraph(terms, styles['Normal']))
            
            # Build PDF
            doc.build(story)
            
            return {
                'success': True,
                'pdf_path': output_path
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': f'PDF generation failed: {str(e)}'
            }





// Relative Path: src\services\stripe_service.py
import os
import stripe
from flask import current_app
from datetime import datetime, timedelta
from src.models.models import db, User, Payment

class StripeService:
    def __init__(self):
        stripe.api_key = os.getenv('STRIPE_SECRET_KEY')
        self.webhook_secret = os.getenv('STRIPE_WEBHOOK_SECRET')
        self.price_id = os.getenv('STRIPE_PRICE_ID')  # Premium subscription price ID
        
    def create_checkout_session(self, user_id, success_url, cancel_url):
        """
        Create a Stripe checkout session for premium upgrade
        """
        try:
            user = User.query.get(user_id)
            if not user:
                return {
                    'success': False,
                    'error': 'User not found'
                }
            
            # Create checkout session
            session = stripe.checkout.Session.create(
                customer_email=user.email,
                payment_method_types=['card'],
                line_items=[
                    {
                        'price': self.price_id,
                        'quantity': 1,
                    }
                ],
                mode='subscription',
                success_url=success_url + '?session_id={CHECKOUT_SESSION_ID}',
                cancel_url=cancel_url,
                metadata={
                    'user_id': str(user_id)
                },
                subscription_data={
                    'metadata': {
                        'user_id': str(user_id)
                    }
                }
            )
            
            return {
                'success': True,
                'checkout_url': session.url,
                'session_id': session.id
            }
            
        except stripe.error.StripeError as e:
            return {
                'success': False,
                'error': f'Stripe error: {str(e)}'
            }
        except Exception as e:
            return {
                'success': False,
                'error': f'Payment error: {str(e)}'
            }
    
    def create_one_time_payment(self, user_id, amount, description, success_url, cancel_url):
        """
        Create a one-time payment session (for additional quotes)
        """
        try:
            user = User.query.get(user_id)
            if not user:
                return {
                    'success': False,
                    'error': 'User not found'
                }
            
            # Create checkout session for one-time payment
            session = stripe.checkout.Session.create(
                customer_email=user.email,
                payment_method_types=['card'],
                line_items=[
                    {
                        'price_data': {
                            'currency': 'eur',
                            'product_data': {
                                'name': description,
                                'description': f'Zusätzliche Angebote für {user.company_name or user.username}'
                            },
                            'unit_amount': int(amount * 100),  # Amount in cents
                        },
                        'quantity': 1,
                    }
                ],
                mode='payment',
                success_url=success_url + '?session_id={CHECKOUT_SESSION_ID}',
                cancel_url=cancel_url,
                metadata={
                    'user_id': str(user_id),
                    'payment_type': 'additional_quotes'
                }
            )
            
            return {
                'success': True,
                'checkout_url': session.url,
                'session_id': session.id
            }
            
        except stripe.error.StripeError as e:
            return {
                'success': False,
                'error': f'Stripe error: {str(e)}'
            }
        except Exception as e:
            return {
                'success': False,
                'error': f'Payment error: {str(e)}'
            }
    
    def handle_webhook(self, payload, sig_header):
        """
        Handle Stripe webhook events
        """
        try:
            event = stripe.Webhook.construct_event(
                payload, sig_header, self.webhook_secret
            )
            
            if event['type'] == 'checkout.session.completed':
                session = event['data']['object']
                self._handle_successful_payment(session)
                
            elif event['type'] == 'customer.subscription.created':
                subscription = event['data']['object']
                self._handle_subscription_created(subscription)
                
            elif event['type'] == 'customer.subscription.updated':
                subscription = event['data']['object']
                self._handle_subscription_updated(subscription)
                
            elif event['type'] == 'customer.subscription.deleted':
                subscription = event['data']['object']
                self._handle_subscription_cancelled(subscription)
                
            elif event['type'] == 'invoice.payment_succeeded':
                invoice = event['data']['object']
                self._handle_invoice_payment_succeeded(invoice)
                
            elif event['type'] == 'invoice.payment_failed':
                invoice = event['data']['object']
                self._handle_invoice_payment_failed(invoice)
            
            return {
                'success': True,
                'message': 'Webhook processed successfully'
            }
            
        except ValueError as e:
            return {
                'success': False,
                'error': f'Invalid payload: {str(e)}'
            }
        except stripe.error.SignatureVerificationError as e:
            return {
                'success': False,
                'error': f'Invalid signature: {str(e)}'
            }
        except Exception as e:
            return {
                'success': False,
                'error': f'Webhook error: {str(e)}'
            }
    
    def _handle_successful_payment(self, session):
        """Handle successful payment completion"""
        try:
            user_id = int(session['metadata']['user_id'])
            user = User.query.get(user_id)
            
            if not user:
                current_app.logger.error(f"User {user_id} not found for payment")
                return
            
            # Create payment record
            payment = Payment(
                user_id=user_id,
                stripe_session_id=session['id'],
                stripe_payment_intent_id=session.get('payment_intent'),
                amount=session['amount_total'] / 100,  # Convert from cents
                currency=session['currency'],
                status='completed',
                payment_type=session['metadata'].get('payment_type', 'subscription')
            )
            
            db.session.add(payment)
            
            # Handle different payment types
            if session['metadata'].get('payment_type') == 'additional_quotes':
                # Add additional quotes (e.g., 10 more quotes)
                user.additional_quotes = (user.additional_quotes or 0) + 10
            else:
                # Premium subscription
                user.is_premium = True
                user.premium_until = datetime.utcnow() + timedelta(days=365)  # 1 year
                user.stripe_customer_id = session.get('customer')
            
            db.session.commit()
            current_app.logger.info(f"Payment processed for user {user_id}")
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error processing payment: {str(e)}")
    
    def _handle_subscription_created(self, subscription):
        """Handle subscription creation"""
        try:
            user_id = int(subscription['metadata']['user_id'])
            user = User.query.get(user_id)
            
            if user:
                user.stripe_subscription_id = subscription['id']
                user.is_premium = True
                user.premium_until = datetime.fromtimestamp(subscription['current_period_end'])
                db.session.commit()
                
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error handling subscription creation: {str(e)}")
    
    def _handle_subscription_updated(self, subscription):
        """Handle subscription updates"""
        try:
            user_id = int(subscription['metadata']['user_id'])
            user = User.query.get(user_id)
            
            if user:
                user.premium_until = datetime.fromtimestamp(subscription['current_period_end'])
                
                # Check if subscription is active
                if subscription['status'] in ['active', 'trialing']:
                    user.is_premium = True
                else:
                    user.is_premium = False
                    
                db.session.commit()
                
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error handling subscription update: {str(e)}")
    
    def _handle_subscription_cancelled(self, subscription):
        """Handle subscription cancellation"""
        try:
            user_id = int(subscription['metadata']['user_id'])
            user = User.query.get(user_id)
            
            if user:
                user.is_premium = False
                user.stripe_subscription_id = None
                db.session.commit()
                
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error handling subscription cancellation: {str(e)}")
    
    def _handle_invoice_payment_succeeded(self, invoice):
        """Handle successful invoice payment"""
        try:
            subscription_id = invoice['subscription']
            if subscription_id:
                subscription = stripe.Subscription.retrieve(subscription_id)
                user_id = int(subscription['metadata']['user_id'])
                user = User.query.get(user_id)
                
                if user:
                    # Reset monthly quote counter on successful payment
                    user.quotes_this_month = 0
                    user.premium_until = datetime.fromtimestamp(subscription['current_period_end'])
                    db.session.commit()
                    
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error handling invoice payment: {str(e)}")
    
    def _handle_invoice_payment_failed(self, invoice):
        """Handle failed invoice payment"""
        try:
            subscription_id = invoice['subscription']
            if subscription_id:
                subscription = stripe.Subscription.retrieve(subscription_id)
                user_id = int(subscription['metadata']['user_id'])
                user = User.query.get(user_id)
                
                if user:
                    # Optionally downgrade user or send notification
                    current_app.logger.warning(f"Payment failed for user {user_id}")
                    
        except Exception as e:
            current_app.logger.error(f"Error handling failed payment: {str(e)}")
    
    def get_customer_portal_url(self, user_id, return_url):
        """
        Create a customer portal session for subscription management
        """
        try:
            user = User.query.get(user_id)
            if not user or not user.stripe_customer_id:
                return {
                    'success': False,
                    'error': 'No Stripe customer found'
                }
            
            session = stripe.billing_portal.Session.create(
                customer=user.stripe_customer_id,
                return_url=return_url
            )
            
            return {
                'success': True,
                'portal_url': session.url
            }
            
        except stripe.error.StripeError as e:
            return {
                'success': False,
                'error': f'Stripe error: {str(e)}'
            }
        except Exception as e:
            return {
                'success': False,
                'error': f'Portal error: {str(e)}'
            }
    
    def cancel_subscription(self, user_id):
        """
        Cancel a user's subscription
        """
        try:
            user = User.query.get(user_id)
            if not user or not user.stripe_subscription_id:
                return {
                    'success': False,
                    'error': 'No active subscription found'
                }
            
            # Cancel at period end to allow access until paid period expires
            stripe.Subscription.modify(
                user.stripe_subscription_id,
                cancel_at_period_end=True
            )
            
            return {
                'success': True,
                'message': 'Subscription will be cancelled at the end of the current period'
            }
            
        except stripe.error.StripeError as e:
            return {
                'success': False,
                'error': f'Stripe error: {str(e)}'
            }
        except Exception as e:
            return {
                'success': False,
                'error': f'Cancellation error: {str(e)}'
            }

class QuotaService:
    """Service to manage user quote quotas"""
    
    @staticmethod
    def can_create_quote(user):
        """Check if user can create a new quote"""
        if user.is_premium:
            return True
        
        # Check monthly limit for free users
        total_available = 3 + (user.additional_quotes or 0)
        return user.quotes_this_month < total_available
    
    @staticmethod
    def increment_quote_count(user):
        """Increment user's monthly quote count"""
        user.quotes_this_month = (user.quotes_this_month or 0) + 1
        db.session.commit()
    
    @staticmethod
    def get_quota_info(user):
        """Get user's quota information"""
        if user.is_premium:
            return {
                'is_premium': True,
                'unlimited': True,
                'quotes_used': user.quotes_this_month or 0
            }
        
        total_available = 3 + (user.additional_quotes or 0)
        quotes_used = user.quotes_this_month or 0
        
        return {
            'is_premium': False,
            'unlimited': False,
            'total_available': total_available,
            'quotes_used': quotes_used,
            'quotes_remaining': max(0, total_available - quotes_used),
            'additional_quotes': user.additional_quotes or 0
        }





// Relative Path: src\services\__init__.py
# Services package





// Relative Path: src\main.py
from fastapi import FastAPI, Depends, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from contextlib import asynccontextmanager
import os
from dotenv import load_dotenv

from src.core.database import init_db
from src.routes import auth, users, quotes, ai, payments

# Load environment variables
load_dotenv()

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    await init_db()
    yield
    # Shutdown
    pass

# Create FastAPI app
app = FastAPI(
    title="Maler Kostenvoranschlag API",
    description="KI-gestützter Kostenvoranschlags-Generator für Malerbetriebe",
    version="2.0.0",
    lifespan=lifespan
)

# CORS configuration
allowed_origins = os.getenv('ALLOWED_ORIGINS', 'http://localhost:5173').split(',')
app.add_middleware(
    CORSMiddleware,
    allow_origins=allowed_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(auth.router, prefix="/api/auth", tags=["authentication"])
app.include_router(users.router, prefix="/api/users", tags=["users"])
app.include_router(quotes.router, prefix="/api/quotes", tags=["quotes"])
app.include_router(ai.router, prefix="/api/ai", tags=["ai"])
app.include_router(payments.router, prefix="/api/payments", tags=["payments"])

# Health check
@app.get("/health")
async def health_check():
    return {"status": "healthy", "message": "Maler Kostenvoranschlag FastAPI is running"}

# Serve static files (for production)
if os.path.exists("static"):
    app.mount("/", StaticFiles(directory="static", html=True), name="static")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8080,
        reload=True,
        log_level="info"
    )





// Relative Path: src\__init__.py



