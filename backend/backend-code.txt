
// Relative Path: alembic\env.py
from logging.config import fileConfig

from sqlalchemy import engine_from_config
from sqlalchemy import pool

from alembic import context

import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

from src.models.models import Base
from src.core.config import settings

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
target_metadata = Base.metadata

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline() -> None:
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = settings.DATABASE_URL
    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online() -> None:
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    configuration = config.get_section(config.config_ini_section)
    configuration["sqlalchemy.url"] = settings.DATABASE_URL
    connectable = engine_from_config(
        configuration,
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    with connectable.connect() as connection:
        context.configure(
            connection=connection, target_metadata=target_metadata
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()




// Relative Path: src\core\database.py
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession, async_sessionmaker
from sqlalchemy.orm import DeclarativeBase
import os
from typing import AsyncGenerator

# Database URL
DATABASE_URL = "sqlite+aiosqlite:///./test_maler_kostenvoranschlag.db"

# Create async engine
engine = create_async_engine(
    DATABASE_URL,
    echo=True,  # Set to False in production
    future=True
)

# Create async session factory
AsyncSessionLocal = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False
)

class Base(DeclarativeBase):
    pass

async def init_db():
    """Initialize database tables"""
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """Dependency to get database session"""
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()





// Relative Path: src\core\security.py
from passlib.context import CryptContext
from jose import JWTError, jwt
from datetime import datetime, timedelta, timezone
from typing import Optional
import os

# Security configuration
SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key-change-in-production")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# Password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against its hash"""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Hash a password"""
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Create a JWT access token"""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def verify_token(token: str) -> Optional[dict]:
    """Verify and decode a JWT token"""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None


# FastAPI dependencies
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from src.core.database import get_db
from src.models.models import User

security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: AsyncSession = Depends(get_db)
) -> User:
    """Get current authenticated user"""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        payload = verify_token(credentials.credentials)
        if payload is None:
            raise credentials_exception
            
        email: str = payload.get("sub")
        if email is None:
            raise credentials_exception
            
    except JWTError:
        raise credentials_exception
    
    # Get user from database
    result = await db.execute(select(User).where(User.email == email))
    user = result.scalar_one_or_none()
    
    if user is None:
        raise credentials_exception
        
    return user

async def get_current_active_user(current_user: User = Depends(get_current_user)) -> User:
    """Get current active user"""
    if not current_user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user





// Relative Path: src\core\__init__.py
# Core package





// Relative Path: src\migrations\versions\add_conversation_history.py
"""add conversation history

Revision ID: add_conversation_history
Revises: 
Create Date: 2024-03-19 16:00:00.000000

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = 'add_conversation_history'
down_revision: Union[str, None] = None
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # Add created_by_ai and conversation_history columns to quotes table
    op.add_column('quotes', sa.Column('created_by_ai', sa.Boolean(), nullable=False, server_default='false'))
    op.add_column('quotes', sa.Column('conversation_history', sa.Text(), nullable=True))


def downgrade() -> None:
    # Remove created_by_ai and conversation_history columns from quotes table
    op.drop_column('quotes', 'conversation_history')
    op.drop_column('quotes', 'created_by_ai') 



// Relative Path: src\models\models.py
from sqlalchemy import Column, Integer, String, Float, Text, DateTime, Boolean, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from src.core.database import Base

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String(50), unique=True, index=True, nullable=False)
    email = Column(String(100), unique=True, index=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    
    # Profile information
    company_name = Column(String(100))
    phone = Column(String(20))
    address = Column(Text)
    
    # Subscription and quota
    is_premium = Column(Boolean, default=False)
    premium_until = Column(DateTime)
    quotes_this_month = Column(Integer, default=0)
    additional_quotes = Column(Integer, default=0)
    
    # Timestamps
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    # Relationships
    quotes = relationship("Quote", back_populates="user", cascade="all, delete-orphan")
    documents = relationship("Document", back_populates="user", cascade="all, delete-orphan")
    payments = relationship("Payment", back_populates="user", cascade="all, delete-orphan")

class Quote(Base):
    __tablename__ = "quotes"
    
    id = Column(Integer, primary_key=True, index=True)
    quote_number = Column(String(50), unique=True, index=True, nullable=False)
    
    # User reference
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    
    # Customer information
    customer_name = Column(String(100), nullable=False)
    customer_email = Column(String(100))
    customer_phone = Column(String(20))
    customer_address = Column(Text)
    
    # Project information
    project_title = Column(String(200), nullable=False)
    project_description = Column(Text)
    
    # Pricing
    total_amount = Column(Float)
    labor_hours = Column(Float)
    hourly_rate = Column(Float)
    material_cost = Column(Float)
    additional_costs = Column(Float)
    
    # Status and processing
    status = Column(String(20), default="draft")  # draft, completed, sent, accepted, rejected
    ai_processing_status = Column(String(20), default="pending")  # pending, processing, completed, failed
    
    # AI and conversation
    created_by_ai = Column(Boolean, default=False)  # Whether this quote was created via AI chat
    conversation_history = Column(Text, nullable=True)  # JSON string of conversation history
    
    # Timestamps
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    # Relationships
    user = relationship("User", back_populates="quotes")
    quote_items = relationship("QuoteItem", back_populates="quote", cascade="all, delete-orphan")
    payments = relationship("Payment", back_populates="quote")

class QuoteItem(Base):
    __tablename__ = "quote_items"
    
    id = Column(Integer, primary_key=True, index=True)
    quote_id = Column(Integer, ForeignKey("quotes.id"), nullable=False)
    
    position = Column(Integer, nullable=False)
    description = Column(Text, nullable=False)
    quantity = Column(Float, nullable=False)
    unit = Column(String(20), nullable=False)
    unit_price = Column(Float, nullable=False)
    total_price = Column(Float, nullable=False)
    
    # Additional information
    room_name = Column(String(100))
    area_sqm = Column(Float)
    work_type = Column(String(50))  # painting, priming, etc.
    
    # Timestamps
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    # Relationships
    quote = relationship("Quote", back_populates="quote_items")

class Document(Base):
    __tablename__ = "documents"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    quote_id = Column(Integer, ForeignKey("quotes.id"))
    
    filename = Column(String(255), nullable=False)
    original_filename = Column(String(255), nullable=False)
    file_path = Column(String(500), nullable=False)
    file_size = Column(Integer)
    mime_type = Column(String(100))
    
    # OCR and analysis results
    extracted_text = Column(Text)
    analysis_result = Column(Text, nullable=True)  # JSON string
    processing_status = Column(String(20), default="pending")  # pending, processing, completed, failed
    
    # Timestamps
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    # Relationships
    user = relationship("User", back_populates="documents")

class Payment(Base):
    __tablename__ = "payments"
    
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    quote_id = Column(Integer, ForeignKey("quotes.id"), nullable=True)
    
    # Stripe information
    stripe_payment_intent_id = Column(String(200), unique=True)
    stripe_session_id = Column(String(200), unique=True)
    
    amount = Column(Float, nullable=False)
    currency = Column(String(3), default="EUR")
    status = Column(String(50), nullable=False)  # pending, completed, failed, refunded
    
    payment_type = Column(String(50), nullable=False)  # premium_upgrade, additional_quotes
    description = Column(String(200))
    
    # Timestamps
    created_at = Column(DateTime, server_default=func.now())
    updated_at = Column(DateTime, server_default=func.now(), onupdate=func.now())
    
    # Relationships
    user = relationship("User", back_populates="payments")
    quote = relationship("Quote", back_populates="payments")





// Relative Path: src\models\user.py
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)

    def __repr__(self):
        return f'<User {self.username}>'

    def to_dict(self):
        return {
            'id': self.id,
            'username': self.username,
            'email': self.email
        }




// Relative Path: src\models\__init__.py
# Models package





// Relative Path: src\routes\ai.py
from fastapi import APIRouter, HTTPException, Depends, UploadFile, File, BackgroundTasks, Form
from typing import List, Dict, Any, Optional
import json
import logging
from datetime import datetime
import os
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
import uuid
import asyncio
import base64

from src.services.ai_service import AIService
from src.services.pdf_service import PDFService
from src.core.security import get_current_user
from src.models.models import User, Quote, QuoteItem, Document as DocumentModel
from src.schemas.schemas import (
    AIAnalysisRequest, 
    AIAnalysisResponse,
    AIQuestionResponse,
    AIFollowUpRequest,
    AIQuoteGenerationRequest,
    AIQuoteGenerationResponse,
    AIConversationHistory,
    DocumentResponse,
    ErrorResponse
)
from src.database import get_db
from .quotes import generate_quote_number

router = APIRouter(tags=["AI"])
logger = logging.getLogger(__name__)

# Initialize AI service
ai_service = AIService()

def default_json(obj):
    if isinstance(obj, datetime):
        return obj.isoformat()
    raise TypeError(f"Type {type(obj)} not serializable")

@router.post("/analyze-input", response_model=AIAnalysisResponse)
async def analyze_project_input(
    request: AIAnalysisRequest,
    current_user: User = Depends(get_current_user)
):
    """Analyze project description and generate intelligent follow-up questions"""
    try:
        logger.info(f"Analyzing project input for user {current_user.id}")
        
        # Initialize conversation history if not exists
        if not request.conversation_history:
            request.conversation_history = []
            
        # Add user's initial input to conversation
        request.conversation_history.append({
            "role": "user",
            "content": request.input,
            "timestamp": datetime.now().isoformat()
        })
        
        result = await ai_service.analyze_project_description(
            description=request.input,
            context=getattr(request, 'context', None) or "initial_input",
            conversation_history=request.conversation_history
        )
        
        # Add AI's response to conversation
        request.conversation_history.append({
            "role": "assistant",
            "content": json.dumps(result),
            "timestamp": datetime.now().isoformat()
        })
        
        print(result)

        return AIAnalysisResponse(
            analysis=result.get("analysis", {}),
            questions=result.get("questions", []),
            suggestions=result.get("suggestions", []),
            conversation_history=request.conversation_history,
            success=True
        )
        
    except Exception as e:
        logger.error(f"Error analyzing project input: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/ask-question", response_model=AIQuestionResponse)
async def ask_follow_up_question(
    request: AIFollowUpRequest,
    current_user: User = Depends(get_current_user)
):
    """Handle follow-up questions in the AI conversation"""
    try:
        logger.info(f"Processing follow-up question for user {current_user.id}")
        
        # Add user's question to conversation
        request.conversation_history.append({
            "role": "user",
            "content": request.question,
            "timestamp": datetime.now().isoformat()
        })
        
        # conversation_history in dicts umwandeln
        history = [msg.model_dump() if hasattr(msg, 'model_dump') else dict(msg) for msg in request.conversation_history]
        
        result = await ai_service.ask_follow_up_question(
            conversation_history=history,
            user_message=request.question
        )
        
        # Add AI's response to conversation
        request.conversation_history.append({
            "role": "assistant",
            "content": result.get("response", ""),
            "timestamp": datetime.now().isoformat()
        })
        
        return AIQuestionResponse(
            response=result.get("response", ""),
            needs_more_info=result.get("needs_more_info", False),
            suggested_questions=result.get("suggested_questions", []),
            conversation_history=request.conversation_history,
            success=True
        )
        
    except Exception as e:
        logger.error(f"Error processing follow-up question: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/generate-quote", response_model=AIQuoteGenerationResponse)
async def generate_quote_with_ai(
    request: AIQuoteGenerationRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Generate a detailed quote based on project data and user answers"""
    try:
        logger.info(f"Generating AI quote for user {current_user.id}")
        print("STEP 1: Starte generate_quote_with_ai")
        # conversation_history in dicts umwandeln
        history = [msg.model_dump() if hasattr(msg, 'model_dump') else dict(msg) for msg in request.conversation_history] if request.conversation_history else None
        print("STEP 2: Nach history umwandeln")

        # Dokumente laden und als base64 encodieren
        quote_id = request.project_data.get('quote_id') if request.project_data else None
        document_files = []
        if quote_id:
            result = await db.execute(
                select(DocumentModel)
                .where(DocumentModel.quote_id == quote_id)
                .where(DocumentModel.user_id == current_user.id)
            )
            documents = result.scalars().all()
            for doc in documents:
                try:
                    with open(doc.file_path, "rb") as f:
                        file_bytes = f.read()
                        encoded = base64.b64encode(file_bytes).decode('utf-8')
                        document_files.append({
                            "filename": doc.filename,
                            "mime_type": doc.mime_type,
                            "base64": encoded
                        })
                except Exception as e:
                    logger.error(f"Error reading document file {doc.file_path}: {str(e)}")
        print(f"STEP 2b: Dokumente als base64 geladen: {len(document_files)}")

        result = await ai_service.process_answers_and_generate_quote(
            project_data=request.project_data,
            answers=request.answers,
            conversation_history=history,
            document_files=document_files
        )
        print("STEP 3: Nach KI-Quote-Generierung")
        # Create quote in database
        quote_number = generate_quote_number()
        print("STEP 4: Nach generate_quote_number")
        # Create quote
        quote = Quote(
            quote_number=quote_number,
            user_id=current_user.id,
            customer_name=request.customer_name,
            customer_email=request.customer_email,
            customer_phone=request.customer_phone,
            customer_address=request.customer_address,
            project_title=result["quote"]["project_title"],
            project_description=result["quote"].get("project_description"),
            status="draft",
            ai_processing_status="completed",
            created_by_ai=True,
            conversation_history=json.dumps(history, default=default_json) if history is not None else None
        )
        print("STEP 5: Nach Quote-Objekt-Erstellung")
        db.add(quote)
        await db.flush()
        print("STEP 6: Nach db.flush()")
        # Add quote items
        total_amount = 0.0
        quote_items_dicts = []
        for idx, item in enumerate(result["items"], start=1):
            quote_item = QuoteItem(
                quote_id=quote.id,
                position=item.get("position", idx),
                description=item["description"],
                quantity=item["quantity"],
                unit=item["unit"],
                unit_price=item["unit_price"],
                total_price=item["total_price"],
                room_name=item.get("room_name"),
                area_sqm=item.get("area_sqm"),
                work_type=item.get("work_type")
            )
            db.add(quote_item)
            total_amount += item["total_price"]
            quote_items_dicts.append({
                "id": quote_item.id,
                "quote_id": quote_item.quote_id,
                "position": quote_item.position,
                "description": quote_item.description,
                "quantity": quote_item.quantity,
                "unit": quote_item.unit,
                "unit_price": quote_item.unit_price,
                "total_price": quote_item.total_price,
                "room_name": quote_item.room_name,
                "created_at": quote_item.created_at,
                "updated_at": quote_item.updated_at
            })
        print("STEP 7: Nach Hinzufügen der QuoteItems")
        # Update quote with total amount
        quote.total_amount = total_amount
        print("STEP 8: Nach Setzen von total_amount")
        await db.commit()
        print("STEP 9: Nach db.commit()")
        pdf_data = {
            "quote_number": quote.quote_number,
            "customer_name": quote.customer_name,
            "customer_email": quote.customer_email,
            "customer_phone": quote.customer_phone,
            "customer_address": quote.customer_address,
            "project_title": quote.project_title,
            "project_description": quote.project_description,
            "quote_items": quote_items_dicts
        }
        print(f"STEP 10: pdf_data: {pdf_data}")
        # Jetzt PDF-Generierung im Threadpool
        pdf_service = PDFService()
        pdf_result = await asyncio.to_thread(pdf_service.generate_quote_pdf, pdf_data)
        print("STEP 11: Nach PDF-Generierung")
        # Add final quote generation to conversation
        if request.conversation_history:
            request.conversation_history.append({
                "role": "assistant",
                "content": "Kostenvoranschlag wurde erstellt und als PDF gespeichert",
                "timestamp": datetime.now().isoformat()
            })
        print("STEP 12: Nach Hinzufügen zur conversation_history")
        return AIQuoteGenerationResponse(
            quote=result.get("quote", {}),
            items=quote_items_dicts,  # Use the complete quote items with all fields
            notes=result.get("notes", ""),
            recommendations=result.get("recommendations", []),
            conversation_history=request.conversation_history,
            total_amount=quote.total_amount,
            success=True,
            pdf_url=pdf_result.get("pdf_url") if pdf_result.get("success") else None
        )
        print("STEP 13: Nach Response")
        
    except Exception as e:
        logger.error(f"Error generating AI quote: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@router.post("/upload-document", response_model=DocumentResponse)
async def upload_document_for_analysis(
    file: UploadFile = File(...),
    quote_id: Optional[int] = Form(None),
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Upload and analyze documents (PDFs, images) for project information"""
    try:
        logger.info(f"Processing document upload for user {current_user.id}")
        
        # Validate file type
        allowed_types = ['application/pdf', 'image/jpeg', 'image/png', 'image/webp']
        if file.content_type not in allowed_types:
            raise HTTPException(
                status_code=400, 
                detail="Unsupported file type. Please upload PDF, JPEG, PNG, or WebP files."
            )
        
        # Read file content
        content = await file.read()
        
        # Create upload directory if it doesn't exist
        upload_dir = os.path.join("uploads", str(current_user.id))
        os.makedirs(upload_dir, exist_ok=True)
        
        # Generate unique filename
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        safe_filename = f"{timestamp}_{file.filename}"
        file_path = os.path.join(upload_dir, safe_filename)
        
        # Save file
        with open(file_path, "wb") as f:
            f.write(content)
        
        # Create document record
        document = DocumentModel(
            user_id=current_user.id,
            filename=safe_filename,
            original_filename=file.filename,
            file_path=file_path,
            file_size=len(content),
            mime_type=file.content_type,
            processing_status="processing",
            quote_id=quote_id
        )
        
        db.add(document)
        await db.commit()
        await db.refresh(document)
        
        # Analyze document in background
        try:
            analysis_result = await ai_service.analyze_document(
                file_content=content,
                filename=file.filename,
                content_type=file.content_type
            )
            
            # Update document with analysis results
            document.extracted_text = analysis_result.get("extracted_text")
            document.analysis_result = json.dumps(analysis_result)
            document.processing_status = "completed"
            
            await db.commit()
            await db.refresh(document)
            
        except Exception as e:
            logger.error(f"Error analyzing document: {str(e)}")
            document.processing_status = "failed"
            await db.commit()
            await db.refresh(document)
        
        # Erstelle das Response-Objekt explizit aus den Attributen
        resp = DocumentResponse(
            id=document.id,
            user_id=document.user_id,
            filename=document.filename,
            original_filename=document.original_filename,
            file_path=document.file_path,
            file_size=document.file_size,
            mime_type=document.mime_type,
            processing_status=document.processing_status,
            quote_id=document.quote_id,
            created_at=document.created_at,
            updated_at=document.updated_at,
            analysis_result=json.loads(document.analysis_result) if document.analysis_result else None
        )
        return resp
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error processing document upload: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to process document")

@router.get("/conversation-history/{quote_id}")
async def get_conversation_history(
    quote_id: int,
    current_user: User = Depends(get_current_user)
):
    """Get conversation history for a specific quote"""
    try:
        # For now, return mock conversation history
        # In production, you would fetch from database
        return {
            "quote_id": quote_id,
            "conversation": [
                {
                    "role": "assistant",
                    "content": "Hallo! Ich helfe Ihnen bei der Erstellung Ihres Kostenvoranschlags. Können Sie mir mehr über Ihr Projekt erzählen?",
                    "timestamp": datetime.now().isoformat()
                },
                {
                    "role": "user", 
                    "content": "Ich möchte mein Wohnzimmer streichen lassen.",
                    "timestamp": datetime.now().isoformat()
                }
            ],
            "success": True
        }
        
    except Exception as e:
        logger.error(f"Error fetching conversation history: {str(e)}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/ai-status")
async def get_ai_status():
    """Get current AI service status and capabilities"""
    return {
        "ai_enabled": ai_service.enabled,
        "model": ai_service.model if ai_service.enabled else None,
        "capabilities": {
            "project_analysis": True,
            "question_generation": True,
            "quote_generation": True,
            "document_analysis": True,  # Now enabled
            "conversation_memory": True
        },
        "status": "operational" if ai_service.enabled else "mock_mode"
    }

@router.get("/document-status/{document_id}", response_model=DocumentResponse)
async def get_document_status(
    document_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get the status and analysis results of an uploaded document"""
    try:
        # Get document
        result = await db.execute(
            select(DocumentModel)
            .where(DocumentModel.id == document_id)
            .where(DocumentModel.user_id == current_user.id)
        )
        document = result.scalar_one_or_none()
        
        if not document:
            raise HTTPException(
                status_code=404,
                detail="Document not found"
            )
        
        return document
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting document status: {str(e)}")
        raise HTTPException(status_code=500, detail="Failed to get document status")





// Relative Path: src\routes\auth.py
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from typing import Optional

from src.core.database import get_db
from src.core.security import verify_password, get_password_hash, create_access_token, verify_token
from src.models.models import User
from src.schemas.schemas import UserCreate, UserResponse, LoginRequest, Token, SuccessResponse

router = APIRouter()
security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security),
    db: AsyncSession = Depends(get_db)
) -> User:
    """Get current authenticated user"""
    token = credentials.credentials
    payload = verify_token(token)
    
    if payload is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    email: str = payload.get("sub")
    if email is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Get user from database
    result = await db.execute(select(User).where(User.email == email))
    user = result.scalar_one_or_none()
    
    if user is None:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    return user

@router.post("/register", response_model=SuccessResponse)
async def register(user_data: UserCreate, db: AsyncSession = Depends(get_db)):
    """Register a new user"""
    
    # Log the incoming request data
    print("Registration request data:", user_data.dict())
    
    # Check if user already exists
    result = await db.execute(
        select(User).where(
            (User.email == user_data.email) | (User.username == user_data.username)
        )
    )
    existing_user = result.scalar_one_or_none()
    
    if existing_user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="User with this email or username already exists"
        )
    
    # Create new user
    hashed_password = get_password_hash(user_data.password)
    db_user = User(
        username=user_data.username,
        email=user_data.email,
        hashed_password=hashed_password,
        company_name=user_data.company_name,
        phone=user_data.phone,
        address=user_data.address
    )
    
    db.add(db_user)
    await db.commit()
    await db.refresh(db_user)
    
    return SuccessResponse(message="User registered successfully")

@router.post("/login")
async def login(login_data: LoginRequest, db: AsyncSession = Depends(get_db)):
    """Authenticate user and return access token"""
    
    # Get user by email
    result = await db.execute(select(User).where(User.email == login_data.email))
    user = result.scalar_one_or_none()
    
    if not user or not verify_password(login_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect email or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # Create access token with email as sub
    access_token = create_access_token(data={"sub": user.email})
    
    return {"access_token": access_token, "token_type": "bearer"}

@router.get("/me", response_model=UserResponse)
async def get_current_user_info(current_user: User = Depends(get_current_user)):
    """Get current user information"""
    return current_user

@router.post("/logout", response_model=SuccessResponse)
async def logout():
    """Logout user (client should discard token)"""
    return SuccessResponse(message="Logged out successfully")





// Relative Path: src\routes\payments.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update
from typing import Dict
import stripe
import os

from src.core.database import get_db
from src.routes.auth import get_current_user
from src.models.models import User, Payment
from src.schemas.schemas import PaymentCreate, PaymentResponse, SuccessResponse

router = APIRouter()

# Stripe configuration
stripe.api_key = os.getenv("STRIPE_SECRET_KEY")
STRIPE_PRICE_ID = os.getenv("STRIPE_PRICE_ID", "price_premium_monthly")

@router.post("/create-checkout-session")
async def create_checkout_session(
    success_url: str,
    cancel_url: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Create Stripe checkout session for premium upgrade"""
    
    try:
        checkout_session = stripe.checkout.Session.create(
            payment_method_types=['card'],
            line_items=[{
                'price': STRIPE_PRICE_ID,
                'quantity': 1,
            }],
            mode='subscription',
            success_url=success_url,
            cancel_url=cancel_url,
            customer_email=current_user.email,
            metadata={
                'user_id': current_user.id,
                'payment_type': 'premium_upgrade'
            }
        )
        
        # Create payment record
        payment = Payment(
            user_id=current_user.id,
            stripe_session_id=checkout_session.id,
            amount=29.99,  # Premium price
            currency="EUR",
            status="pending",
            payment_type="premium_upgrade",
            description="Premium Subscription"
        )
        
        db.add(payment)
        await db.commit()
        
        return {
            "success": True,
            "checkout_url": checkout_session.url,
            "session_id": checkout_session.id
        }
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to create checkout session: {str(e)}"
        )

@router.post("/create-additional-quotes-session")
async def create_additional_quotes_session(
    amount: float,
    description: str,
    success_url: str,
    cancel_url: str,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Create checkout session for additional quotes"""
    
    try:
        checkout_session = stripe.checkout.Session.create(
            payment_method_types=['card'],
            line_items=[{
                'price_data': {
                    'currency': 'eur',
                    'product_data': {
                        'name': description,
                    },
                    'unit_amount': int(amount * 100),  # Convert to cents
                },
                'quantity': 1,
            }],
            mode='payment',
            success_url=success_url,
            cancel_url=cancel_url,
            customer_email=current_user.email,
            metadata={
                'user_id': current_user.id,
                'payment_type': 'additional_quotes',
                'amount': amount
            }
        )
        
        # Create payment record
        payment = Payment(
            user_id=current_user.id,
            stripe_session_id=checkout_session.id,
            amount=amount,
            currency="EUR",
            status="pending",
            payment_type="additional_quotes",
            description=description
        )
        
        db.add(payment)
        await db.commit()
        
        return {
            "success": True,
            "checkout_url": checkout_session.url,
            "session_id": checkout_session.id
        }
        
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to create checkout session: {str(e)}"
        )

@router.get("/quota-info")
async def get_quota_info(current_user: User = Depends(get_current_user)):
    """Get current user quota information"""
    
    total_available = 3  # Free tier
    if current_user.is_premium:
        total_available = -1  # Unlimited
    
    quotes_remaining = max(0, total_available - current_user.quotes_this_month) if total_available > 0 else -1
    
    return {
        "success": True,
        "quota": {
            "is_premium": current_user.is_premium,
            "unlimited": current_user.is_premium,
            "total_available": total_available,
            "quotes_used": current_user.quotes_this_month,
            "quotes_remaining": quotes_remaining,
            "additional_quotes": current_user.additional_quotes
        }
    }

@router.post("/webhook")
async def stripe_webhook(
    request: Dict,
    db: AsyncSession = Depends(get_db)
):
    """Handle Stripe webhook events"""
    
    # In a real implementation, you would verify the webhook signature
    # For now, we'll process the event directly
    
    event_type = request.get('type')
    data = request.get('data', {}).get('object', {})
    
    if event_type == 'checkout.session.completed':
        session_id = data.get('id')
        metadata = data.get('metadata', {})
        user_id = metadata.get('user_id')
        payment_type = metadata.get('payment_type')
        
        if user_id and session_id:
            # Update payment status
            await db.execute(
                update(Payment)
                .where(Payment.stripe_session_id == session_id)
                .values(status="completed")
            )
            
            # Update user based on payment type
            if payment_type == 'premium_upgrade':
                # Upgrade user to premium
                await db.execute(
                    update(User)
                    .where(User.id == int(user_id))
                    .values(is_premium=True)
                )
            elif payment_type == 'additional_quotes':
                # Add additional quotes (assuming 10 quotes for 19.99€)
                amount = float(metadata.get('amount', 19.99))
                additional_quotes = 10 if amount >= 19.99 else 5
                
                await db.execute(
                    update(User)
                    .where(User.id == int(user_id))
                    .values(additional_quotes=User.additional_quotes + additional_quotes)
                )
            
            await db.commit()
    
    return {"status": "success"}

@router.get("/payments", response_model=list[PaymentResponse])
async def get_user_payments(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get payment history for current user"""
    
    result = await db.execute(
        select(Payment)
        .where(Payment.user_id == current_user.id)
        .order_by(Payment.created_at.desc())
    )
    payments = result.scalars().all()
    
    return payments





// Relative Path: src\routes\quotes.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update, func
from sqlalchemy.orm import selectinload
from typing import List, Optional
from datetime import datetime
import uuid
import json

from src.core.database import get_db
from src.routes.auth import get_current_user
from src.models.models import User, Quote, QuoteItem
from src.schemas.schemas import (
    QuoteCreate, QuoteUpdate, QuoteResponse, QuoteItemCreate, 
    SuccessResponse, ErrorResponse, GenerateQuoteAIRequest
)
from src.services.ai_service import AIService

router = APIRouter()
ai_service = AIService()

def generate_quote_number() -> str:
    """Generate unique quote number"""
    timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
    return f"KV-{timestamp}"

async def check_user_quota(user: User, db: AsyncSession) -> bool:
    """Check if user can create a new quote"""
    if user.is_premium:
        return True
    
    # Check free tier quota (3 per month)
    if user.quotes_this_month >= 3:
        # Check additional quotes
        if user.additional_quotes > 0:
            # Deduct from additional quotes
            await db.execute(
                update(User)
                .where(User.id == user.id)
                .values(additional_quotes=User.additional_quotes - 1)
            )
            await db.commit()
            return True
        return False
    
    # User hasn't reached monthly limit, increment counter
    await db.execute(
        update(User)
        .where(User.id == user.id)
        .values(quotes_this_month=User.quotes_this_month + 1)
    )
    await db.commit()
    return True

def quote_to_response(quote):
    return {
        "id": quote.id,
        "quote_number": quote.quote_number,
        "user_id": quote.user_id,
        "customer_name": quote.customer_name,
        "customer_email": quote.customer_email,
        "customer_phone": quote.customer_phone,
        "customer_address": quote.customer_address,
        "project_title": quote.project_title,
        "project_description": quote.project_description or "",
        "total_amount": quote.total_amount,
        "status": quote.status,
        "created_by_ai": quote.created_by_ai,
        "conversation_history": json.loads(quote.conversation_history) if quote.conversation_history else [],
        "items": [
            {
                "id": item.id,
                "quote_id": item.quote_id,
                "position": item.position,
                "description": item.description,
                "quantity": item.quantity,
                "unit": item.unit,
                "unit_price": item.unit_price,
                "total_price": item.total_price,
                "room_name": item.room_name,
                "created_at": item.created_at,
                "updated_at": item.updated_at
            }
            for item in quote.quote_items
        ],
        "created_at": quote.created_at,
        "updated_at": quote.updated_at,
    }

@router.get("/", response_model=List[QuoteResponse])
async def get_quotes(
    status_filter: Optional[str] = None,
    limit: int = 50,
    offset: int = 0,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get all quotes for current user"""
    
    query = select(Quote).where(Quote.user_id == current_user.id)
    
    if status_filter:
        query = query.where(Quote.status == status_filter)
    
    query = query.options(selectinload(Quote.quote_items)).order_by(Quote.created_at.desc()).limit(limit).offset(offset)
    
    result = await db.execute(query)
    quotes = result.scalars().all()
    
    return [quote_to_response(q) for q in quotes]

@router.post("/", response_model=QuoteResponse)
async def create_quote(
    quote_data: QuoteCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Create a new quote"""
    
    # Check user quota
    # if not await check_user_quota(current_user, db):
    #     raise HTTPException(
    #         status_code=status.HTTP_403_FORBIDDEN,
    #         detail="Quote limit reached. Please upgrade to premium or purchase additional quotes."
    #     )
    
    # Create quote
    quote_number = generate_quote_number()
    
    # Convert conversation history to JSON string if present
    conversation_history = None
    if quote_data.conversation_history:
        conversation_history = json.dumps([msg.model_dump() for msg in quote_data.conversation_history])
    
    quote = Quote(
        quote_number=quote_number,
        user_id=current_user.id,
        customer_name=quote_data.customer_name,
        customer_email=quote_data.customer_email,
        customer_phone=quote_data.customer_phone,
        customer_address=quote_data.customer_address,
        project_title=quote_data.project_title,
        project_description=quote_data.project_description,
        status="draft",
        ai_processing_status="pending",
        created_by_ai=quote_data.created_by_ai,
        conversation_history=conversation_history
    )
    
    db.add(quote)
    await db.flush()  # This will get us the quote.id without committing
    
    # Add quote items
    total_amount = 0.0
    for item_data in quote_data.quote_items:
        quote_item = QuoteItem(
            quote_id=quote.id,
            position=item_data.position,
            description=item_data.description,
            quantity=item_data.quantity,
            unit=item_data.unit,
            unit_price=item_data.unit_price,
            total_price=item_data.total_price,
            room_name=item_data.room_name,
            area_sqm=item_data.area_sqm,
            work_type=item_data.work_type
        )
        db.add(quote_item)
        total_amount += item_data.total_price
    
    # Update quote with total amount
    quote.total_amount = total_amount
    quote.ai_processing_status = "completed"
    
    await db.commit()
    
    # Load the complete quote with items
    result = await db.execute(
        select(Quote)
        .where(Quote.id == quote.id)
        .options(selectinload(Quote.quote_items))
    )
    quote = result.scalar_one()
    
    return quote

@router.get("/{quote_id}", response_model=QuoteResponse)
async def get_quote(
    quote_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Get specific quote"""
    result = await db.execute(
        select(Quote)
        .where(Quote.id == quote_id)
        .where(Quote.user_id == current_user.id)
        .options(selectinload(Quote.quote_items))
    )
    quote = result.scalar_one_or_none()

    if not quote:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Quote not found"
        )

    return quote_to_response(quote)

@router.put("/{quote_id}", response_model=QuoteResponse)
async def update_quote(
    quote_id: int,
    quote_update: QuoteUpdate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Update a quote"""
    
    result = await db.execute(
        select(Quote)
        .where(Quote.id == quote_id)
        .where(Quote.user_id == current_user.id)
    )
    quote = result.scalar_one_or_none()
    
    if not quote:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Quote not found"
        )
    
    # Update quote
    update_data = quote_update.model_dump(exclude_unset=True)
    
    # Convert conversation history to JSON string if present
    if "conversation_history" in update_data:
        update_data["conversation_history"] = json.dumps(
            [msg.model_dump() for msg in update_data["conversation_history"]]
        )
    
    if update_data:
        await db.execute(
            update(Quote)
            .where(Quote.id == quote_id)
            .values(**update_data)
        )
        await db.commit()
        await db.refresh(quote)
    
    # Load quote items
    items_result = await db.execute(
        select(QuoteItem)
        .where(QuoteItem.quote_id == quote.id)
        .order_by(QuoteItem.position)
    )
    quote.quote_items = items_result.scalars().all()
    
    return quote

@router.delete("/{quote_id}", response_model=SuccessResponse)
async def delete_quote(
    quote_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Delete a quote"""
    
    result = await db.execute(
        select(Quote)
        .where(Quote.id == quote_id)
        .where(Quote.user_id == current_user.id)
    )
    quote = result.scalar_one_or_none()
    
    if not quote:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Quote not found"
        )
    
    await db.delete(quote)
    await db.commit()
    
    return SuccessResponse(message="Quote deleted successfully")

@router.post("/{quote_id}/generate-ai", response_model=QuoteResponse)
async def generate_quote_with_ai(
    quote_id: int,
    request: GenerateQuoteAIRequest,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Generate quote items using AI based on project description"""
    
    result = await db.execute(
        select(Quote)
        .where(Quote.id == quote_id)
        .where(Quote.user_id == current_user.id)
    )
    quote = result.scalar_one_or_none()
    
    if not quote:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Quote not found"
        )
    
    try:
        # Update processing status
        await db.execute(
            update(Quote)
            .where(Quote.id == quote_id)
            .values(ai_processing_status="processing")
        )
        await db.commit()
        
        # Analyze with AI
        analysis = await ai_service.analyze_project_description(
            description=request.project_description, 
            context="quote_generation"
        )
        
        # Clear existing quote items
        existing_items = (await db.execute(
            select(QuoteItem).where(QuoteItem.quote_id == quote_id)
        )).scalars().all()
        
        for item in existing_items:
            await db.delete(item)
        
        # Create new quote items from AI suggestions
        total_amount = 0.0
        suggested_items = analysis.get("suggested_items", [])
        
        for i, item_data in enumerate(suggested_items, 1):
            quote_item = QuoteItem(
                quote_id=quote.id,
                position=i,
                description=item_data.get("description", ""),
                quantity=item_data.get("quantity", 1),
                unit=item_data.get("unit", "Stk"),
                unit_price=item_data.get("unit_price", 0),
                total_price=item_data.get("total_price", 0),
                work_type=item_data.get("work_type", "")
            )
            db.add(quote_item)
            total_amount += quote_item.total_price
        
        # Update quote
        await db.execute(
            update(Quote)
            .where(Quote.id == quote_id)
            .values(
                total_amount=total_amount,
                ai_processing_status="completed",
                project_description=request.project_description
            )
        )
        
        await db.commit()
        
        # Load the complete quote with items
        result = await db.execute(
            select(Quote)
            .where(Quote.id == quote.id)
            .options(selectinload(Quote.quote_items))
        )
        quote = result.scalar_one()
        
        return quote
        
    except Exception as e:
        # Update status to failed
        await db.execute(
            update(Quote)
            .where(Quote.id == quote_id)
            .values(ai_processing_status="failed")
        )
        await db.commit()
        
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"AI quote generation failed: {str(e)}"
        )

@router.post("/{quote_id}/duplicate", response_model=QuoteResponse)
async def duplicate_quote(
    quote_id: int,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Duplicate an existing quote"""
    
    # Check user quota
    # if not await check_user_quota(current_user, db):
    #     raise HTTPException(
    #         status_code=status.HTTP_403_FORBIDDEN,
    #         detail="Quote limit reached. Please upgrade to premium or purchase additional quotes."
    #     )
    
    result = await db.execute(
        select(Quote)
        .where(Quote.id == quote_id)
        .where(Quote.user_id == current_user.id)
    )
    original_quote = result.scalar_one_or_none()
    
    if not original_quote:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Quote not found"
        )
    
    # Create new quote
    new_quote_number = generate_quote_number()
    
    new_quote = Quote(
        quote_number=new_quote_number,
        user_id=current_user.id,
        customer_name=f"Kopie - {original_quote.customer_name}",
        customer_email=original_quote.customer_email,
        customer_phone=original_quote.customer_phone,
        customer_address=original_quote.customer_address,
        project_title=f"Kopie - {original_quote.project_title}",
        project_description=original_quote.project_description,
        total_amount=original_quote.total_amount,
        labor_hours=original_quote.labor_hours,
        hourly_rate=original_quote.hourly_rate,
        material_cost=original_quote.material_cost,
        additional_costs=original_quote.additional_costs,
        status="draft",
        ai_processing_status="completed"
    )
    
    db.add(new_quote)
    await db.commit()
    await db.refresh(new_quote)
    
    # Copy quote items
    items_result = await db.execute(
        select(QuoteItem)
        .where(QuoteItem.quote_id == quote_id)
        .order_by(QuoteItem.position)
    )
    original_items = items_result.scalars().all()
    
    for original_item in original_items:
        new_item = QuoteItem(
            quote_id=new_quote.id,
            position=original_item.position,
            description=original_item.description,
            quantity=original_item.quantity,
            unit=original_item.unit,
            unit_price=original_item.unit_price,
            total_price=original_item.total_price,
            room_name=original_item.room_name,
            area_sqm=original_item.area_sqm,
            work_type=original_item.work_type
        )
        db.add(new_item)
    
    await db.commit()
    
    # Load new quote with items
    items_result = await db.execute(
        select(QuoteItem)
        .where(QuoteItem.quote_id == new_quote.id)
        .order_by(QuoteItem.position)
    )
    new_quote.quote_items = items_result.scalars().all()
    
    return new_quote





// Relative Path: src\routes\user.py
from flask import Blueprint, jsonify, request
from src.models.models import User, db
from datetime import datetime

user_bp = Blueprint('user', __name__)

@user_bp.route('/users', methods=['GET'])
def get_users():
    """Get all users (admin only)"""
    try:
        users = User.query.all()
        return jsonify([user.to_dict() for user in users])
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@user_bp.route('/users', methods=['POST'])
def create_user():
    """Create a new user"""
    try:
        data = request.json
        
        # Validate required fields
        required_fields = ['email', 'username']
        for field in required_fields:
            if not data.get(field):
                return jsonify({'error': f'Missing required field: {field}'}), 400
        
        # Check if user already exists
        existing_user = User.query.filter_by(email=data['email']).first()
        if existing_user:
            return jsonify({'error': 'User with this email already exists'}), 400
        
        user = User(
            email=data['email'],
            username=data['username'],
            company_name=data.get('company_name'),
            phone=data.get('phone'),
            address=data.get('address'),
            supabase_user_id=data.get('supabase_user_id')
        )
        
        db.session.add(user)
        db.session.commit()
        
        return jsonify(user.to_dict()), 201
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@user_bp.route('/users/<int:user_id>', methods=['GET'])
def get_user(user_id):
    """Get a specific user"""
    try:
        user = User.query.get_or_404(user_id)
        return jsonify(user.to_dict())
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@user_bp.route('/users/by-email/<email>', methods=['GET'])
def get_user_by_email(email):
    """Get user by email"""
    try:
        user = User.query.filter_by(email=email).first()
        if not user:
            return jsonify({'error': 'User not found'}), 404
        return jsonify(user.to_dict())
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@user_bp.route('/users/by-supabase-id/<supabase_id>', methods=['GET'])
def get_user_by_supabase_id(supabase_id):
    """Get user by Supabase user ID"""
    try:
        user = User.query.filter_by(supabase_user_id=supabase_id).first()
        if not user:
            return jsonify({'error': 'User not found'}), 404
        return jsonify(user.to_dict())
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@user_bp.route('/users/<int:user_id>', methods=['PUT'])
def update_user(user_id):
    """Update a user"""
    try:
        user = User.query.get_or_404(user_id)
        data = request.json
        
        # Update fields
        updatable_fields = ['username', 'company_name', 'phone', 'address']
        for field in updatable_fields:
            if field in data:
                setattr(user, field, data[field])
        
        user.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify(user.to_dict())
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@user_bp.route('/users/<int:user_id>', methods=['DELETE'])
def delete_user(user_id):
    """Delete a user"""
    try:
        user = User.query.get_or_404(user_id)
        db.session.delete(user)
        db.session.commit()
        return '', 204
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@user_bp.route('/users/<int:user_id>/increment-quotes', methods=['POST'])
def increment_user_quotes(user_id):
    """Increment user's monthly quote counter"""
    try:
        user = User.query.get_or_404(user_id)
        user.quotes_this_month += 1
        user.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({
            'quotes_this_month': user.quotes_this_month,
            'can_create_more': user.is_premium or user.quotes_this_month < 3
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500

@user_bp.route('/users/<int:user_id>/reset-monthly-quotes', methods=['POST'])
def reset_monthly_quotes(user_id):
    """Reset user's monthly quote counter (admin only)"""
    try:
        user = User.query.get_or_404(user_id)
        user.quotes_this_month = 0
        user.updated_at = datetime.utcnow()
        db.session.commit()
        
        return jsonify({'message': 'Monthly quotes reset', 'quotes_this_month': 0})
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': str(e)}), 500





// Relative Path: src\routes\users.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, update
from typing import List

from src.core.database import get_db
from src.routes.auth import get_current_user
from src.models.models import User
from src.schemas.schemas import UserResponse, UserUpdate, SuccessResponse

router = APIRouter()

@router.get("/profile", response_model=UserResponse)
async def get_user_profile(current_user: User = Depends(get_current_user)):
    """Get current user profile"""
    return current_user

@router.put("/profile", response_model=UserResponse)
async def update_user_profile(
    user_update: UserUpdate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Update current user profile"""
    
    # Check if username/email is already taken by another user
    if user_update.username or user_update.email:
        conditions = []
        if user_update.username:
            conditions.append(User.username == user_update.username)
        if user_update.email:
            conditions.append(User.email == user_update.email)
        
        result = await db.execute(
            select(User).where(
                (conditions[0] if len(conditions) == 1 else conditions[0] | conditions[1]) &
                (User.id != current_user.id)
            )
        )
        existing_user = result.scalar_one_or_none()
        
        if existing_user:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Username or email already taken"
            )
    
    # Update user
    update_data = user_update.model_dump(exclude_unset=True)
    if update_data:
        await db.execute(
            update(User).where(User.id == current_user.id).values(**update_data)
        )
        await db.commit()
        
        # Refresh user data
        await db.refresh(current_user)
    
    return current_user

@router.delete("/profile", response_model=SuccessResponse)
async def delete_user_account(
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """Delete current user account"""
    
    await db.delete(current_user)
    await db.commit()
    
    return SuccessResponse(message="Account deleted successfully")

@router.get("/quota", response_model=dict)
async def get_user_quota(current_user: User = Depends(get_current_user)):
    """Get current user quota information"""
    
    total_available = 3  # Free tier
    if current_user.is_premium:
        total_available = -1  # Unlimited
    
    quotes_remaining = max(0, total_available - current_user.quotes_this_month) if total_available > 0 else -1
    
    return {
        "is_premium": current_user.is_premium,
        "unlimited": current_user.is_premium,
        "total_available": total_available,
        "quotes_used": current_user.quotes_this_month,
        "quotes_remaining": quotes_remaining,
        "additional_quotes": current_user.additional_quotes
    }





// Relative Path: src\routes\__init__.py
# Routes package





// Relative Path: src\schemas\schemas.py
from typing import Optional, List, Dict, Any
from pydantic import BaseModel, EmailStr, Field
from datetime import datetime
from enum import Enum

# Base Models
class UserBase(BaseModel):
    email: EmailStr
    username: str
    company_name: Optional[str] = None
    phone: Optional[str] = None
    address: Optional[str] = None

class QuoteBase(BaseModel):
    customer_name: str
    project_title: str
    project_description: str
    total_amount: float
    status: str = "draft"
    created_by_ai: bool = False
    conversation_history: Optional[str] = None

class QuoteItemBase(BaseModel):
    description: str
    quantity: float
    unit_price: float
    total_price: float

class PaymentBase(BaseModel):
    amount: float
    status: str
    payment_method: str

# Error Models
class ErrorResponse(BaseModel):
    detail: str
    code: Optional[str] = None

# AI Models
class AIConversationMessage(BaseModel):
    role: str
    content: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)

class AIConversationHistory(BaseModel):
    messages: List[AIConversationMessage]
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

class AIAnalysisRequest(BaseModel):
    input: str
    conversation_history: Optional[List[AIConversationMessage]] = None

class AIAnalysisResponse(BaseModel):
    analysis: Dict[str, Any]
    questions: List[Dict[str, Any]]
    suggestions: List[str]
    conversation_history: List[AIConversationMessage]

class AIFollowUpRequest(BaseModel):
    question: str
    conversation_history: List[AIConversationMessage]

class AIQuestionResponse(BaseModel):
    response: str
    needs_more_info: bool
    conversation_history: List[AIConversationMessage]

class GenerateQuoteAIRequest(BaseModel):
    project_data: Dict[str, Any]
    answers: List[Dict[str, Any]]
    conversation_history: List[AIConversationMessage]

class AIQuoteGenerationRequest(BaseModel):
    project_data: Dict[str, Any]
    answers: List[Dict[str, Any]]
    conversation_history: List[AIConversationMessage]
    customer_name: str
    customer_address: str
    customer_email: str
    customer_phone: str

class AIQuoteGenerationResponse(BaseModel):
    quote: Dict[str, Any]
    items: List[Dict[str, Any]]
    total_amount: float
    conversation_history: List[AIConversationMessage]
    pdf_url: Optional[str] = None

# Create Models
class UserCreate(UserBase):
    password: str

class QuoteCreate(QuoteBase):
    items: List[QuoteItemBase]
    conversation_history: Optional[List[AIConversationMessage]] = None

class QuoteItemCreate(QuoteItemBase):
    pass

class PaymentCreate(PaymentBase):
    quote_id: int

# Update Models
class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None
    password: Optional[str] = None

class QuoteUpdate(QuoteBase):
    items: Optional[List[QuoteItemBase]] = None
    conversation_history: Optional[List[AIConversationMessage]] = None

class QuoteItemUpdate(QuoteItemBase):
    pass

class PaymentUpdate(PaymentBase):
    pass

# Response Models
class UserResponse(BaseModel):
    id: int
    username: str
    email: EmailStr
    company_name: Optional[str] = None
    phone: Optional[str] = None
    address: Optional[str] = None
    is_premium: bool = False
    premium_until: Optional[datetime] = None
    quotes_this_month: int = 0
    additional_quotes: int = 0
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

class QuoteItemResponse(QuoteItemBase):
    id: int
    quote_id: int
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

class QuoteResponse(QuoteBase):
    id: int
    quote_number: str
    user_id: int
    items: List[QuoteItemResponse]
    created_at: datetime
    updated_at: datetime
    created_by_ai: bool
    conversation_history: Optional[List[AIConversationMessage]] = None

    class Config:
        from_attributes = True

class PaymentResponse(PaymentBase):
    id: int
    quote_id: int
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True

# Auth Models
class LoginRequest(BaseModel):
    email: EmailStr
    password: str

class Token(BaseModel):
    access_token: str
    token_type: str

class SuccessResponse(BaseModel):
    message: str

# Document Models
class DocumentBase(BaseModel):
    filename: str
    original_filename: str
    file_path: str
    file_size: int
    mime_type: str
    processing_status: str = "pending"
    quote_id: Optional[int] = None

class DocumentCreate(DocumentBase):
    pass

class DocumentUpdate(BaseModel):
    processing_status: Optional[str] = None
    analysis_result: Optional[Dict[str, Any]] = None

class DocumentResponse(DocumentBase):
    id: int
    user_id: int
    created_at: datetime
    updated_at: datetime
    analysis_result: Optional[Dict[str, Any]] = None

    class Config:
        from_attributes = True

class Document(BaseModel):
    id: int
    user_id: int
    filename: str
    original_filename: str
    file_path: str
    file_size: int
    mime_type: str
    processing_status: str
    analysis_result: Optional[Dict[str, Any]] = None
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True 



// Relative Path: src\schemas\__init__.py
# Schemas package





// Relative Path: src\services\ai_service.py
import os
import openai
import json
import asyncio
from typing import Dict, List, Optional, Any
from datetime import datetime
import logging
import base64

logger = logging.getLogger(__name__)

class AIService:
    def __init__(self):
        api_key = os.getenv('OPENAI_API_KEY')
        if api_key and api_key != 'test_key_placeholder' and api_key.startswith('sk-'):
            self.client = openai.AsyncOpenAI(api_key=api_key)
            self.model = "gpt-4.1-mini"
            self.enabled = True
            logger.info("OpenAI client initialized successfully")
        else:
            self.client = None
            self.model = None
            self.enabled = False
            logger.warning("OpenAI API key not configured, using mock responses")

    async def analyze_project_description(self, description: str, context: str = "initial_input", conversation_history: Optional[List[Dict]] = None) -> Dict:
        """Analyze project description and generate intelligent follow-up questions"""
        
        if not self.enabled:
            return self._get_mock_analysis_response(description)
        
        try:
            system_prompt = """Du bist ein erfahrener Maler-Experte und KI-Assistent für Kostenvoranschläge. 
            Deine Aufgabe ist es, Projektbeschreibungen zu analysieren und intelligente Rückfragen zu stellen, 
            um alle notwendigen Informationen für einen präzisen Kostenvoranschlag zu sammeln.

            Analysiere die Projektbeschreibung und generiere 2-4 relevante Rückfragen als Multiple-Choice oder 
            offene Fragen. Fokussiere dich auf:
            - Fehlende technische Details (Fläche, Höhe, Zustand)
            - Materialwünsche und Qualität
            - Zeitrahmen und Zugänglichkeit
            - Vorarbeiten und Besonderheiten

            Antworte im JSON-Format:
            {
                "analysis": {
                    "project_type": "string",
                    "estimated_area": "number or null",
                    "complexity": "low|medium|high",
                    "missing_info": ["list of missing information"]
                },
                "questions": [
                    {
                        "id": "unique_id",
                        "question": "Frage-Text",
                        "type": "multiple_choice|text|number",
                        "options": ["option1", "option2"] // nur bei multiple_choice
                    }
                ],
                "suggestions": ["hilfreiche Tipps für den Kunden"]
            }"""

            # Build conversation context
            messages = [{"role": "system", "content": system_prompt}]
            
            if conversation_history:
                for msg in conversation_history[-5:]:  # Last 5 messages for context
                    messages.append({
                        "role": msg.get("role", "user"),
                        "content": msg.get("content", "")
                    })
            
            messages.append({
                "role": "user",
                "content": f"""Projektbeschreibung: {description}

                Kontext: {context}
                
                Bitte analysiere diese Beschreibung und stelle intelligente Rückfragen."""
            })

            response = await self.client.chat.completions.create(
                model=self.model,
                messages=messages,
                temperature=0.7,
                max_tokens=1500
            )

            content = response.choices[0].message.content
            
            # Parse JSON response
            try:
                # remove '''json ''' from content
                content = content.replace('```json', '').replace('```', '')
                result = json.loads(content)
                return result
            except json.JSONDecodeError:
                logger.error(f"Failed to parse OpenAI JSON response: {content}")
                return self._get_mock_analysis_response(description)

        except Exception as e:
            logger.error(f"OpenAI API error: {str(e)}")
            return self._get_mock_analysis_response(description)

    async def process_answers_and_generate_quote(self, 
                                                project_data: Dict, 
                                                answers: List[Dict],
                                                conversation_history: Optional[List[Dict]] = None,
                                                document_files: Optional[List[Dict]] = None) -> Dict:
        """Process user answers and generate a detailed quote, including multimodal document files as base64."""
        
        if not self.enabled:
            return self._get_mock_quote_response(project_data, answers)
        
        try:
            system_prompt = """Du bist ein erfahrener Maler-Meister und erstellst präzise Kostenvoranschläge.
            Basierend auf der Projektbeschreibung, den Antworten des Kunden und den angehängten Dokumenten (Pläne, Fotos), erstelle einen detaillierten Kostenvoranschlag mit realistischen Preisen für den deutschen Markt.

            Berücksichtige:
            - Materialkosten (Farbe, Grundierung, Werkzeug)
            - Arbeitszeit (Vorbereitung, Streichen, Nacharbeiten)
            - Schwierigkeitsgrad und Zugänglichkeit
            - Regionale Preisunterschiede (Deutschland)
            - Mehrwertsteuer (19%)
            - Die Inhalte und Hinweise aus den hochgeladenen Dokumenten

            Antworte im JSON-Format:
            {
                "quote": {
                    "project_title": "string",
                    "total_amount": number,
                    "labor_hours": number,
                    "hourly_rate": number,
                    "material_cost": number,
                    "additional_costs": number
                },
                "items": [
                    {
                        "description": "string",
                        "quantity": number,
                        "unit": "string",
                        "unit_price": number,
                        "total_price": number,
                        "category": "labor|material|additional"
                    }
                ],
                "notes": "string",
                "recommendations": ["string"]
            }"""

            # Build conversation context
            messages = [{"role": "system", "content": system_prompt}]
            
            if conversation_history:
                for msg in conversation_history[-5:]:  # Last 5 messages for context
                    messages.append({
                        "role": msg.get("role", "user"),
                        "content": msg.get("content", "")
                    })
            
            # Haupt-User-Message mit Projektdaten und Antworten
            user_content = [
                {"type": "text", "text": f"Projektdaten:\n{json.dumps(project_data, indent=2, ensure_ascii=False)}\n\nKundenantworten:\n{json.dumps(answers, indent=2, ensure_ascii=False)}\n\nErstelle einen detaillierten Kostenvoranschlag."}
            ]
            # Multimodale Dokumente als image_url/base64 anhängen
            if document_files:
                for doc in document_files:
                    if doc.get("base64") and doc.get("mime_type"):
                        user_content.append({
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:{doc['mime_type']};base64,{doc['base64']}"
                            }
                        })
            messages.append({
                "role": "user",
                "content": user_content
            })

            response = await self.client.chat.completions.create(
                model=self.model,
                messages=messages,
                temperature=0.3,
                max_tokens=2000
            )

            content = response.choices[0].message.content
            
            try:
                result = json.loads(content)
                return result
            except json.JSONDecodeError:
                logger.error(f"Failed to parse OpenAI quote JSON: {content}")
                return self._get_mock_quote_response(project_data, answers)

        except Exception as e:
            logger.error(f"OpenAI API error in quote generation: {str(e)}")
            return self._get_mock_quote_response(project_data, answers)

    async def ask_follow_up_question(self, conversation_history: List[Dict], 
                                   user_message: str) -> Dict:
        """Handle follow-up questions in the conversation"""
        
        if not self.enabled:
            return self._get_mock_followup_response(user_message)
        
        try:
            system_prompt = """Du bist ein hilfsreicher KI-Assistent für Maler-Kostenvoranschläge.
            Beantworte Fragen des Kunden höflich und kompetent. Wenn zusätzliche Informationen 
            benötigt werden, stelle gezielte Nachfragen.

            Antworte im JSON-Format:
            {
                "response": "string",
                "needs_more_info": boolean,
                "suggested_questions": ["string"] // optional
            }"""

            # Build conversation context
            messages = [{"role": "system", "content": system_prompt}]
            
            for msg in conversation_history[-5:]:  # Last 5 messages for context
                messages.append({
                    "role": msg.get("role", "user"),
                    "content": msg.get("content", "")
                })
            
            messages.append({"role": "user", "content": user_message})

            response = await self.client.chat.completions.create(
                model=self.model,
                messages=messages,
                temperature=0.7,
                max_tokens=800
            )

            content = response.choices[0].message.content
            
            try:
                result = json.loads(content)
                return result
            except json.JSONDecodeError:
                # Fallback to simple text response
                return {
                    "response": content,
                    "needs_more_info": False,
                    "suggested_questions": []
                }

        except Exception as e:
            logger.error(f"OpenAI API error in follow-up: {str(e)}")
            return self._get_mock_followup_response(user_message)

    async def analyze_document(self, file_content: bytes, filename: str, content_type: str) -> Dict:
        """Analyze uploaded document (floor plan, photo) using AI"""
        
        if not self.enabled:
            return self._get_mock_document_analysis()
        
        try:
            # Convert file content to base64
            base64_content = base64.b64encode(file_content).decode('utf-8')
            
            system_prompt = """Du bist ein Experte für die Analyse von Grundrissen und Fotos von Räumen.
            Analysiere das Bild und extrahiere relevante Informationen für einen Maler-Kostenvoranschlag.

            Antworte im JSON-Format:
            {
                "extracted_text": "string",
                "detected_rooms": ["string"],
                "estimated_area": number,
                "notes": "string",
                "recommendations": ["string"]
            }"""

            messages = [
                {"role": "system", "content": system_prompt},
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "text",
                            "text": f"Bitte analysiere dieses Bild ({filename}) für einen Maler-Kostenvoranschlag."
                        },
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:{content_type};base64,{base64_content}"
                            }
                        }
                    ]
                }
            ]

            response = await self.client.chat.completions.create(
                model=self.model,
                messages=messages,
                temperature=0.3,
                max_tokens=1000
            )

            content = response.choices[0].message.content
            
            try:
                result = json.loads(content)
                return result
            except json.JSONDecodeError:
                logger.error(f"Failed to parse OpenAI document analysis JSON: {content}")
                return self._get_mock_document_analysis()

        except Exception as e:
            logger.error(f"OpenAI API error in document analysis: {str(e)}")
            return self._get_mock_document_analysis()

    def _get_mock_analysis_response(self, description: str) -> Dict:
        """Mock response for testing without OpenAI API"""
        return {
            "analysis": {
                "project_type": "Innenraumstreichung",
                "estimated_area": 25,
                "complexity": "medium",
                "missing_info": ["Genaue Quadratmeter", "Farbwunsch", "Vorarbeiten"]
            },
            "questions": [
                {
                    "id": "area_size",
                    "question": "Wie groß ist die zu streichende Fläche in Quadratmetern?",
                    "type": "multiple_choice",
                    "options": ["Unter 20m²", "20-40m²", "40-60m²", "Über 60m²"]
                },
                {
                    "id": "paint_type",
                    "question": "Welche Art von Farbe soll verwendet werden?",
                    "type": "multiple_choice",
                    "options": ["Standard-Wandfarbe", "Premium-Farbe", "Spezialfarbe", "Kundenwunsch"]
                },
                {
                    "id": "prep_work",
                    "question": "Sind Vorarbeiten nötig (z.B. Spachteln, Grundierung)?",
                    "type": "multiple_choice",
                    "options": ["Ja, umfangreich", "Ja, minimal", "Nein", "Unsicher"]
                }
            ],
            "suggestions": [
                "Vielen Dank für die Information. Können Sie mir noch sagen, ob spezielle Vorbereitungen nötig sind?",
                "Kleinere Ausbesserungen können den Preis beeinflussen."
            ]
        }

    def _get_mock_quote_response(self, project_data: Dict, answers: List[Dict]) -> Dict:
        """Mock response for quote generation without OpenAI API"""
        return {
            "quote": {
                "project_title": "Wohnzimmer streichen",
                "total_amount": 1250.00,
                "labor_hours": 16.0,
                "hourly_rate": 45.00,
                "material_cost": 530.00,
                "additional_costs": 0.00
            },
            "items": [
                {
                    "description": "Wandflächen grundieren und streichen",
                    "quantity": 25.5,
                    "unit": "m²",
                    "unit_price": 15.00,
                    "total_price": 382.50,
                    "category": "labor"
                },
                {
                    "description": "Premium-Wandfarbe",
                    "quantity": 2,
                    "unit": "Eimer",
                    "unit_price": 45.00,
                    "total_price": 90.00,
                    "category": "material"
                }
            ],
            "notes": "Preis inkl. MwSt. Material wird gestellt.",
            "recommendations": [
                "Möbel sollten vor Arbeitsbeginn ausgeräumt werden",
                "Für optimale Ergebnisse empfehlen wir eine Grundierung"
            ]
        }

    def _get_mock_followup_response(self, message: str) -> Dict:
        """Mock response for follow-up questions without OpenAI API"""
        return {
            "response": "Vielen Dank für Ihre Antwort. Können Sie mir noch sagen, ob es besondere Wünsche bezüglich der Farbqualität gibt?",
            "needs_more_info": True,
            "suggested_questions": [
                "Möchten Sie eine besonders hochwertige Farbe verwenden?",
                "Gibt es spezielle Anforderungen an die Haltbarkeit?"
            ]
        }

    def _get_mock_document_analysis(self) -> Dict:
        """Mock response for document analysis without OpenAI API"""
        return {
            "extracted_text": "Wohnzimmer, 25m², 2.50m Deckenhöhe",
            "detected_rooms": ["Wohnzimmer"],
            "estimated_area": 25,
            "notes": "Grundriss zeigt rechteckigen Raum mit Fenster",
            "recommendations": [
                "Deckenhöhe berücksichtigen bei Materialberechnung",
                "Fensterbereich separat kalkulieren"
            ]
        }





// Relative Path: src\services\pdf_service.py
import os
import smtplib
import requests
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication
from datetime import datetime
from jinja2 import Template
import json

class PDFService:
    def __init__(self):
        self.craftmypdf_api_key = os.getenv('CRAFTMYPDF_API_KEY')
        self.craftmypdf_template_id = os.getenv('CRAFTMYPDF_TEMPLATE_ID')
        self.base_url = 'https://api.craftmypdf.com/v1'
    
    def generate_quote_pdf(self, quote_data):
        """
        Generate PDF using CraftMyPDF API
        """
        try:
            # Prepare data for PDF template
            pdf_data = self._prepare_pdf_data(quote_data)
            
            # Make API request to CraftMyPDF
            headers = {
                'X-API-KEY': self.craftmypdf_api_key,
                'Content-Type': 'application/json'
            }
            
            payload = {
                'template_id': self.craftmypdf_template_id,
                'data': pdf_data,
                'export_type': 'pdf',
                'expiration': 60  # PDF expires in 60 minutes
            }
            
            response = requests.post(
                f'{self.base_url}/create',
                headers=headers,
                json=payload
            )
            
            if response.status_code == 200:
                result = response.json()
                return {
                    'success': True,
                    'pdf_url': result.get('file'),
                    'download_url': result.get('file'),
                    'expires_at': result.get('expires_at')
                }
            else:
                return {
                    'success': False,
                    'error': f'PDF generation failed: {response.text}'
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': f'PDF generation error: {str(e)}'
            }
    
    def _prepare_pdf_data(self, quote_data):
        """
        Prepare quote data for PDF template
        """
        # Format currency
        def format_currency(amount):
            return f"{amount:,.2f} €".replace(',', '.')
        
        # Calculate totals
        subtotal = sum(item['total_price'] for item in quote_data['quote_items'])
        vat_rate = 0.19  # 19% VAT
        vat_amount = subtotal * vat_rate
        total_amount = subtotal + vat_amount
        
        return {
            # Quote information
            'quote_number': quote_data['quote_number'],
            'quote_date': datetime.now().strftime('%d.%m.%Y'),
            'valid_until': (datetime.now().replace(day=datetime.now().day + 30)).strftime('%d.%m.%Y'),
            
            # Customer information
            'customer_name': quote_data['customer_name'],
            'customer_email': quote_data.get('customer_email', ''),
            'customer_phone': quote_data.get('customer_phone', ''),
            'customer_address': quote_data.get('customer_address', ''),
            
            # Project information
            'project_title': quote_data['project_title'],
            'project_description': quote_data.get('project_description', ''),
            
            # Quote items
            'quote_items': [
                {
                    'position': item['position'],
                    'description': item['description'],
                    'quantity': f"{item['quantity']:.1f}",
                    'unit': item['unit'],
                    'unit_price': format_currency(item['unit_price']),
                    'total_price': format_currency(item['total_price']),
                    'room_name': item.get('room_name', '')
                }
                for item in quote_data['quote_items']
            ],
            
            # Totals
            'subtotal': format_currency(subtotal),
            'vat_rate': f"{vat_rate * 100:.0f}%",
            'vat_amount': format_currency(vat_amount),
            'total_amount': format_currency(total_amount),
            
            # Company information (from environment or config)
            'company_name': os.getenv('COMPANY_NAME', 'Ihr Malerbetrieb'),
            'company_address': os.getenv('COMPANY_ADDRESS', 'Musterstraße 123\n12345 Musterstadt'),
            'company_phone': os.getenv('COMPANY_PHONE', '+49 123 456789'),
            'company_email': os.getenv('COMPANY_EMAIL', 'info@malerbetrieb.de'),
            'company_website': os.getenv('COMPANY_WEBSITE', 'www.malerbetrieb.de'),
            'company_tax_number': os.getenv('COMPANY_TAX_NUMBER', 'DE123456789'),
            
            # Terms and conditions
            'payment_terms': '30 Tage netto',
            'warranty_terms': '2 Jahre Gewährleistung auf Malerarbeiten',
            'notes': 'Alle Preise verstehen sich zzgl. der gesetzlichen Mehrwertsteuer.'
        }

class EmailService:
    def __init__(self):
        self.smtp_server = os.getenv('SMTP_SERVER', 'smtp.gmail.com')
        self.smtp_port = int(os.getenv('SMTP_PORT', '587'))
        self.smtp_username = os.getenv('SMTP_USERNAME')
        self.smtp_password = os.getenv('SMTP_PASSWORD')
        self.from_email = os.getenv('FROM_EMAIL', self.smtp_username)
        self.from_name = os.getenv('FROM_NAME', 'Ihr Malerbetrieb')
    
    def send_quote_email(self, quote_data, pdf_url=None):
        """
        Send quote email to customer
        """
        try:
            # Create message
            msg = MIMEMultipart()
            msg['From'] = f"{self.from_name} <{self.from_email}>"
            msg['To'] = quote_data['customer_email']
            msg['Subject'] = f"Kostenvoranschlag {quote_data['quote_number']} - {quote_data['project_title']}"
            
            # Email body
            email_body = self._generate_email_body(quote_data)
            msg.attach(MIMEText(email_body, 'html', 'utf-8'))
            
            # Attach PDF if available
            if pdf_url:
                try:
                    pdf_response = requests.get(pdf_url)
                    if pdf_response.status_code == 200:
                        pdf_attachment = MIMEApplication(pdf_response.content, _subtype='pdf')
                        pdf_attachment.add_header(
                            'Content-Disposition', 
                            'attachment', 
                            filename=f"{quote_data['quote_number']}.pdf"
                        )
                        msg.attach(pdf_attachment)
                except Exception as e:
                    print(f"Warning: Could not attach PDF: {e}")
            
            # Send email
            with smtplib.SMTP(self.smtp_server, self.smtp_port) as server:
                server.starttls()
                server.login(self.smtp_username, self.smtp_password)
                server.send_message(msg)
            
            return {
                'success': True,
                'message': 'Email sent successfully'
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': f'Email sending failed: {str(e)}'
            }
    
    def _generate_email_body(self, quote_data):
        """
        Generate HTML email body
        """
        template_str = """
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <style>
                body { font-family: Arial, sans-serif; line-height: 1.6; color: #333; }
                .header { background-color: #f8f9fa; padding: 20px; border-radius: 5px; margin-bottom: 20px; }
                .content { margin: 20px 0; }
                .footer { margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee; font-size: 12px; color: #666; }
                .highlight { background-color: #e3f2fd; padding: 15px; border-radius: 5px; margin: 15px 0; }
                .button { 
                    display: inline-block; 
                    padding: 12px 24px; 
                    background-color: #2196f3; 
                    color: white; 
                    text-decoration: none; 
                    border-radius: 5px; 
                    margin: 10px 0;
                }
            </style>
        </head>
        <body>
            <div class="header">
                <h2>Kostenvoranschlag {{ quote_number }}</h2>
                <p>{{ project_title }}</p>
            </div>
            
            <div class="content">
                <p>Sehr geehrte/r {{ customer_name }},</p>
                
                <p>vielen Dank für Ihre Anfrage. Gerne übersenden wir Ihnen hiermit unseren Kostenvoranschlag für das Projekt "{{ project_title }}".</p>
                
                <div class="highlight">
                    <h3>Projektdetails:</h3>
                    <ul>
                        <li><strong>Angebotsnummer:</strong> {{ quote_number }}</li>
                        <li><strong>Projekt:</strong> {{ project_title }}</li>
                        <li><strong>Gesamtsumme:</strong> {{ total_amount }} (inkl. MwSt.)</li>
                        <li><strong>Gültig bis:</strong> {{ valid_until }}</li>
                    </ul>
                </div>
                
                <p>Den detaillierten Kostenvoranschlag finden Sie im Anhang als PDF-Datei.</p>
                
                <p>Bei Fragen stehen wir Ihnen gerne zur Verfügung. Wir freuen uns auf Ihre Rückmeldung und die Zusammenarbeit mit Ihnen.</p>
                
                <p>Mit freundlichen Grüßen<br>
                {{ company_name }}</p>
            </div>
            
            <div class="footer">
                <p>{{ company_name }}<br>
                {{ company_address }}<br>
                Tel: {{ company_phone }}<br>
                E-Mail: {{ company_email }}</p>
                
                <p><small>Diese E-Mail wurde automatisch generiert. Bei Fragen antworten Sie bitte direkt auf diese E-Mail.</small></p>
            </div>
        </body>
        </html>
        """
        
        template = Template(template_str)
        
        # Calculate total amount
        subtotal = sum(item['total_price'] for item in quote_data['quote_items'])
        vat_amount = subtotal * 0.19
        total_amount = subtotal + vat_amount
        
        return template.render(
            quote_number=quote_data['quote_number'],
            customer_name=quote_data['customer_name'],
            project_title=quote_data['project_title'],
            total_amount=f"{total_amount:,.2f} €".replace(',', '.'),
            valid_until=(datetime.now().replace(day=datetime.now().day + 30)).strftime('%d.%m.%Y'),
            company_name=os.getenv('COMPANY_NAME', 'Ihr Malerbetrieb'),
            company_address=os.getenv('COMPANY_ADDRESS', 'Musterstraße 123, 12345 Musterstadt'),
            company_phone=os.getenv('COMPANY_PHONE', '+49 123 456789'),
            company_email=os.getenv('COMPANY_EMAIL', 'info@malerbetrieb.de')
        )

# Alternative: Simple PDF generation using reportlab (fallback)
class SimplePDFService:
    def __init__(self):
        pass
    
    def generate_simple_pdf(self, quote_data, output_path):
        """
        Generate simple PDF using reportlab as fallback
        """
        try:
            from reportlab.lib.pagesizes import A4
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib.units import cm
            from reportlab.lib import colors
            
            # Create PDF document
            doc = SimpleDocTemplate(output_path, pagesize=A4)
            styles = getSampleStyleSheet()
            story = []
            
            # Title
            title_style = ParagraphStyle(
                'CustomTitle',
                parent=styles['Heading1'],
                fontSize=24,
                spaceAfter=30,
                textColor=colors.HexColor('#2196f3')
            )
            story.append(Paragraph("KOSTENVORANSCHLAG", title_style))
            story.append(Spacer(1, 20))
            
            # Quote info
            quote_info = f"""
            <b>Angebotsnummer:</b> {quote_data['quote_number']}<br/>
            <b>Datum:</b> {datetime.now().strftime('%d.%m.%Y')}<br/>
            <b>Projekt:</b> {quote_data['project_title']}<br/>
            """
            story.append(Paragraph(quote_info, styles['Normal']))
            story.append(Spacer(1, 20))
            
            # Customer info
            customer_info = f"""
            <b>Kunde:</b><br/>
            {quote_data['customer_name']}<br/>
            {quote_data.get('customer_address', '')}<br/>
            {quote_data.get('customer_email', '')}<br/>
            {quote_data.get('customer_phone', '')}
            """
            story.append(Paragraph(customer_info, styles['Normal']))
            story.append(Spacer(1, 30))
            
            # Quote items table
            table_data = [['Pos.', 'Beschreibung', 'Menge', 'Einheit', 'Einzelpreis', 'Gesamtpreis']]
            
            for item in quote_data['quote_items']:
                table_data.append([
                    str(item['position']),
                    item['description'],
                    f"{item['quantity']:.1f}",
                    item['unit'],
                    f"{item['unit_price']:.2f} €",
                    f"{item['total_price']:.2f} €"
                ])
            
            # Calculate totals
            subtotal = sum(item['total_price'] for item in quote_data['quote_items'])
            vat_amount = subtotal * 0.19
            total_amount = subtotal + vat_amount
            
            # Add totals
            table_data.append(['', '', '', '', 'Zwischensumme:', f"{subtotal:.2f} €"])
            table_data.append(['', '', '', '', 'MwSt. (19%):', f"{vat_amount:.2f} €"])
            table_data.append(['', '', '', '', 'Gesamtsumme:', f"{total_amount:.2f} €"])
            
            table = Table(table_data, colWidths=[1*cm, 6*cm, 2*cm, 2*cm, 3*cm, 3*cm])
            table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('GRID', (0, 0), (-1, -1), 1, colors.black),
                ('FONTNAME', (0, -3), (-1, -1), 'Helvetica-Bold'),
                ('BACKGROUND', (0, -1), (-1, -1), colors.lightgrey),
            ]))
            
            story.append(table)
            story.append(Spacer(1, 30))
            
            # Terms
            terms = """
            <b>Zahlungsbedingungen:</b> 30 Tage netto<br/>
            <b>Gewährleistung:</b> 2 Jahre auf Malerarbeiten<br/>
            <b>Gültigkeit:</b> 30 Tage ab Angebotsdatum<br/><br/>
            Alle Preise verstehen sich zzgl. der gesetzlichen Mehrwertsteuer.
            """
            story.append(Paragraph(terms, styles['Normal']))
            
            # Build PDF
            doc.build(story)
            
            return {
                'success': True,
                'pdf_path': output_path
            }
            
        except Exception as e:
            return {
                'success': False,
                'error': f'PDF generation failed: {str(e)}'
            }





// Relative Path: src\services\stripe_service.py
import os
import stripe
from flask import current_app
from datetime import datetime, timedelta
from src.models.models import db, User, Payment

class StripeService:
    def __init__(self):
        stripe.api_key = os.getenv('STRIPE_SECRET_KEY')
        self.webhook_secret = os.getenv('STRIPE_WEBHOOK_SECRET')
        self.price_id = os.getenv('STRIPE_PRICE_ID')  # Premium subscription price ID
        
    def create_checkout_session(self, user_id, success_url, cancel_url):
        """
        Create a Stripe checkout session for premium upgrade
        """
        try:
            user = User.query.get(user_id)
            if not user:
                return {
                    'success': False,
                    'error': 'User not found'
                }
            
            # Create checkout session
            session = stripe.checkout.Session.create(
                customer_email=user.email,
                payment_method_types=['card'],
                line_items=[
                    {
                        'price': self.price_id,
                        'quantity': 1,
                    }
                ],
                mode='subscription',
                success_url=success_url + '?session_id={CHECKOUT_SESSION_ID}',
                cancel_url=cancel_url,
                metadata={
                    'user_id': str(user_id)
                },
                subscription_data={
                    'metadata': {
                        'user_id': str(user_id)
                    }
                }
            )
            
            return {
                'success': True,
                'checkout_url': session.url,
                'session_id': session.id
            }
            
        except stripe.error.StripeError as e:
            return {
                'success': False,
                'error': f'Stripe error: {str(e)}'
            }
        except Exception as e:
            return {
                'success': False,
                'error': f'Payment error: {str(e)}'
            }
    
    def create_one_time_payment(self, user_id, amount, description, success_url, cancel_url):
        """
        Create a one-time payment session (for additional quotes)
        """
        try:
            user = User.query.get(user_id)
            if not user:
                return {
                    'success': False,
                    'error': 'User not found'
                }
            
            # Create checkout session for one-time payment
            session = stripe.checkout.Session.create(
                customer_email=user.email,
                payment_method_types=['card'],
                line_items=[
                    {
                        'price_data': {
                            'currency': 'eur',
                            'product_data': {
                                'name': description,
                                'description': f'Zusätzliche Angebote für {user.company_name or user.username}'
                            },
                            'unit_amount': int(amount * 100),  # Amount in cents
                        },
                        'quantity': 1,
                    }
                ],
                mode='payment',
                success_url=success_url + '?session_id={CHECKOUT_SESSION_ID}',
                cancel_url=cancel_url,
                metadata={
                    'user_id': str(user_id),
                    'payment_type': 'additional_quotes'
                }
            )
            
            return {
                'success': True,
                'checkout_url': session.url,
                'session_id': session.id
            }
            
        except stripe.error.StripeError as e:
            return {
                'success': False,
                'error': f'Stripe error: {str(e)}'
            }
        except Exception as e:
            return {
                'success': False,
                'error': f'Payment error: {str(e)}'
            }
    
    def handle_webhook(self, payload, sig_header):
        """
        Handle Stripe webhook events
        """
        try:
            event = stripe.Webhook.construct_event(
                payload, sig_header, self.webhook_secret
            )
            
            if event['type'] == 'checkout.session.completed':
                session = event['data']['object']
                self._handle_successful_payment(session)
                
            elif event['type'] == 'customer.subscription.created':
                subscription = event['data']['object']
                self._handle_subscription_created(subscription)
                
            elif event['type'] == 'customer.subscription.updated':
                subscription = event['data']['object']
                self._handle_subscription_updated(subscription)
                
            elif event['type'] == 'customer.subscription.deleted':
                subscription = event['data']['object']
                self._handle_subscription_cancelled(subscription)
                
            elif event['type'] == 'invoice.payment_succeeded':
                invoice = event['data']['object']
                self._handle_invoice_payment_succeeded(invoice)
                
            elif event['type'] == 'invoice.payment_failed':
                invoice = event['data']['object']
                self._handle_invoice_payment_failed(invoice)
            
            return {
                'success': True,
                'message': 'Webhook processed successfully'
            }
            
        except ValueError as e:
            return {
                'success': False,
                'error': f'Invalid payload: {str(e)}'
            }
        except stripe.error.SignatureVerificationError as e:
            return {
                'success': False,
                'error': f'Invalid signature: {str(e)}'
            }
        except Exception as e:
            return {
                'success': False,
                'error': f'Webhook error: {str(e)}'
            }
    
    def _handle_successful_payment(self, session):
        """Handle successful payment completion"""
        try:
            user_id = int(session['metadata']['user_id'])
            user = User.query.get(user_id)
            
            if not user:
                current_app.logger.error(f"User {user_id} not found for payment")
                return
            
            # Create payment record
            payment = Payment(
                user_id=user_id,
                stripe_session_id=session['id'],
                stripe_payment_intent_id=session.get('payment_intent'),
                amount=session['amount_total'] / 100,  # Convert from cents
                currency=session['currency'],
                status='completed',
                payment_type=session['metadata'].get('payment_type', 'subscription')
            )
            
            db.session.add(payment)
            
            # Handle different payment types
            if session['metadata'].get('payment_type') == 'additional_quotes':
                # Add additional quotes (e.g., 10 more quotes)
                user.additional_quotes = (user.additional_quotes or 0) + 10
            else:
                # Premium subscription
                user.is_premium = True
                user.premium_until = datetime.utcnow() + timedelta(days=365)  # 1 year
                user.stripe_customer_id = session.get('customer')
            
            db.session.commit()
            current_app.logger.info(f"Payment processed for user {user_id}")
            
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error processing payment: {str(e)}")
    
    def _handle_subscription_created(self, subscription):
        """Handle subscription creation"""
        try:
            user_id = int(subscription['metadata']['user_id'])
            user = User.query.get(user_id)
            
            if user:
                user.stripe_subscription_id = subscription['id']
                user.is_premium = True
                user.premium_until = datetime.fromtimestamp(subscription['current_period_end'])
                db.session.commit()
                
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error handling subscription creation: {str(e)}")
    
    def _handle_subscription_updated(self, subscription):
        """Handle subscription updates"""
        try:
            user_id = int(subscription['metadata']['user_id'])
            user = User.query.get(user_id)
            
            if user:
                user.premium_until = datetime.fromtimestamp(subscription['current_period_end'])
                
                # Check if subscription is active
                if subscription['status'] in ['active', 'trialing']:
                    user.is_premium = True
                else:
                    user.is_premium = False
                    
                db.session.commit()
                
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error handling subscription update: {str(e)}")
    
    def _handle_subscription_cancelled(self, subscription):
        """Handle subscription cancellation"""
        try:
            user_id = int(subscription['metadata']['user_id'])
            user = User.query.get(user_id)
            
            if user:
                user.is_premium = False
                user.stripe_subscription_id = None
                db.session.commit()
                
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error handling subscription cancellation: {str(e)}")
    
    def _handle_invoice_payment_succeeded(self, invoice):
        """Handle successful invoice payment"""
        try:
            subscription_id = invoice['subscription']
            if subscription_id:
                subscription = stripe.Subscription.retrieve(subscription_id)
                user_id = int(subscription['metadata']['user_id'])
                user = User.query.get(user_id)
                
                if user:
                    # Reset monthly quote counter on successful payment
                    user.quotes_this_month = 0
                    user.premium_until = datetime.fromtimestamp(subscription['current_period_end'])
                    db.session.commit()
                    
        except Exception as e:
            db.session.rollback()
            current_app.logger.error(f"Error handling invoice payment: {str(e)}")
    
    def _handle_invoice_payment_failed(self, invoice):
        """Handle failed invoice payment"""
        try:
            subscription_id = invoice['subscription']
            if subscription_id:
                subscription = stripe.Subscription.retrieve(subscription_id)
                user_id = int(subscription['metadata']['user_id'])
                user = User.query.get(user_id)
                
                if user:
                    # Optionally downgrade user or send notification
                    current_app.logger.warning(f"Payment failed for user {user_id}")
                    
        except Exception as e:
            current_app.logger.error(f"Error handling failed payment: {str(e)}")
    
    def get_customer_portal_url(self, user_id, return_url):
        """
        Create a customer portal session for subscription management
        """
        try:
            user = User.query.get(user_id)
            if not user or not user.stripe_customer_id:
                return {
                    'success': False,
                    'error': 'No Stripe customer found'
                }
            
            session = stripe.billing_portal.Session.create(
                customer=user.stripe_customer_id,
                return_url=return_url
            )
            
            return {
                'success': True,
                'portal_url': session.url
            }
            
        except stripe.error.StripeError as e:
            return {
                'success': False,
                'error': f'Stripe error: {str(e)}'
            }
        except Exception as e:
            return {
                'success': False,
                'error': f'Portal error: {str(e)}'
            }
    
    def cancel_subscription(self, user_id):
        """
        Cancel a user's subscription
        """
        try:
            user = User.query.get(user_id)
            if not user or not user.stripe_subscription_id:
                return {
                    'success': False,
                    'error': 'No active subscription found'
                }
            
            # Cancel at period end to allow access until paid period expires
            stripe.Subscription.modify(
                user.stripe_subscription_id,
                cancel_at_period_end=True
            )
            
            return {
                'success': True,
                'message': 'Subscription will be cancelled at the end of the current period'
            }
            
        except stripe.error.StripeError as e:
            return {
                'success': False,
                'error': f'Stripe error: {str(e)}'
            }
        except Exception as e:
            return {
                'success': False,
                'error': f'Cancellation error: {str(e)}'
            }

class QuotaService:
    """Service to manage user quote quotas"""
    
    @staticmethod
    def can_create_quote(user):
        """Check if user can create a new quote"""
        if user.is_premium:
            return True
        
        # Check monthly limit for free users
        total_available = 3 + (user.additional_quotes or 0)
        return user.quotes_this_month < total_available
    
    @staticmethod
    def increment_quote_count(user):
        """Increment user's monthly quote count"""
        user.quotes_this_month = (user.quotes_this_month or 0) + 1
        db.session.commit()
    
    @staticmethod
    def get_quota_info(user):
        """Get user's quota information"""
        if user.is_premium:
            return {
                'is_premium': True,
                'unlimited': True,
                'quotes_used': user.quotes_this_month or 0
            }
        
        total_available = 3 + (user.additional_quotes or 0)
        quotes_used = user.quotes_this_month or 0
        
        return {
            'is_premium': False,
            'unlimited': False,
            'total_available': total_available,
            'quotes_used': quotes_used,
            'quotes_remaining': max(0, total_available - quotes_used),
            'additional_quotes': user.additional_quotes or 0
        }





// Relative Path: src\services\__init__.py
# Services package





// Relative Path: src\database.py
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy.pool import NullPool

# Database URL - using SQLite for development
DATABASE_URL = "sqlite+aiosqlite:///./test_maler_kostenvoranschlag.db"

# Create async engine
engine = create_async_engine(
    DATABASE_URL,
    echo=True,
    future=True,
    poolclass=NullPool  # SQLite doesn't support connection pooling
)

# Create async session factory
async_session = sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autocommit=False,
    autoflush=False
)

# Create base class for models
Base = declarative_base()

# Dependency to get DB session
async def get_db() -> AsyncSession:
    async with async_session() as session:
        try:
            yield session
        finally:
            await session.close() 



// Relative Path: src\main.py
from fastapi import FastAPI, Depends, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from contextlib import asynccontextmanager
import os
from dotenv import load_dotenv

from src.core.database import init_db
from src.routes import auth, users, quotes, ai, payments

# Load environment variables
load_dotenv()

@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup
    await init_db()
    yield
    # Shutdown
    pass

# Create FastAPI app
app = FastAPI(
    title="Maler Kostenvoranschlag API",
    description="KI-gestützter Kostenvoranschlags-Generator für Malerbetriebe",
    version="2.0.0",
    lifespan=lifespan
)

# CORS configuration
allowed_origins = os.getenv('ALLOWED_ORIGINS', 'http://localhost:5173').split(',')
app.add_middleware(
    CORSMiddleware,
    allow_origins=allowed_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include routers
app.include_router(auth.router, prefix="/api/auth", tags=["authentication"])
app.include_router(users.router, prefix="/api/users", tags=["users"])
app.include_router(quotes.router, prefix="/api/quotes", tags=["quotes"])
app.include_router(ai.router, prefix="/api/ai", tags=["ai"])
app.include_router(payments.router, prefix="/api/payments", tags=["payments"])

# Health check
@app.get("/health")
async def health_check():
    return {"status": "healthy", "message": "Maler Kostenvoranschlag FastAPI is running"}

# Serve static files (for production)
if os.path.exists("static"):
    app.mount("/", StaticFiles(directory="static", html=True), name="static")

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8080,
        reload=True,
        log_level="info"
    )





// Relative Path: src\__init__.py



